"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var t=require("itee-database"),r=require("itee-validators"),n=e(r),o=e(require("path")),i=require("buffer"),a=e(require("fs")),s=require("stream"),c=require("itee-utils");require("mongoose");var u=require("three-full"),d=require("itee-client"),l=require("bson");console.log("Itee.Database.MongoDB v1.0.1 - EsModule"),console.log("Itee.Database v8.0.2 - EsModule");
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TDatabaseController
 * @classdesc The TDatabaseController is the base class to perform CRUD operations on the database
 */
class m{static __checkData(e,t,n){const o=t.body,i=t.params,a=t.query;return r.isDefined(o)&&o[e]?o[e]:r.isDefined(i)&&i[e]?i[e]:r.isDefined(a)&&a[e]?a[e]:void m.returnError({title:"Erreur de paramètre",message:`${e} n'existe pas dans les paramètres !`},n)}static _formatError(e){let t=[];if(r.isArray(e))for(let r=0,n=e.length;r<n;++r)t=t.concat(m._formatError(e[r]));else if(r.isObject(e))if("ValidationError"===e.name){let r="",n=e.errors;for(let e in n)Object.prototype.hasOwnProperty.call(n,e)&&(r+=n[e].message+"<br>");t.push({title:"Erreur de validation",message:r||"Aucun message d'erreur... Gloups !"})}else"VersionError"===e.name?t.push({title:"Erreur de base de donnée",message:"Aucun document correspondant n'as put être trouvé pour la requete !"}):t.push({title:e.title||"Erreur",message:e.message||"Aucun message d'erreur... Gloups !"});else{if(!r.isString(e))throw new Error(`Unknown error type: ${e} !`);t.push({title:"Erreur",message:e})}return t}static returnNotFound(e){if(r.isFunction(e))return e();e.headersSent||e.status(204).end()}static returnError(e,t){if(r.isFunction(t))return t(e,null);if(t.headersSent)return;const n=m._formatError(e);t.format({"application/json":()=>{t.status(500).json(n)},default:()=>{t.status(406).send("Not Acceptable")}})}static returnData(e,t){if(r.isFunction(t))return t(null,e);if(t.headersSent)return;const n=r.isArray(e)?e:[e];t.format({"application/json":()=>{t.status(200).json(n)},default:()=>{t.status(406).send("Not Acceptable")}})}static returnErrorAndData(e,t,n){if(r.isFunction(n))return n(e,t);if(n.headersSent)return;const o={errors:e,datas:t};n.format({"application/json":()=>{n.status(416).json(o)},default:()=>{n.status(416).send("Range Not Satisfiable")}})}constructor(e={}){const t={driver:null,useNext:!1,...e};this._driver=t.driver,this._useNext=t.useNext}return(e,t={}){const n=Object.assign({immediate:null,beforeAll:null,beforeReturnErrorAndData:null,afterReturnErrorAndData:null,beforeReturnError:null,afterReturnError:null,beforeReturnData:null,afterReturnData:null,beforeReturnNotFound:null,afterReturnNotFound:null,afterAll:null},t,{returnErrorAndData:m.returnErrorAndData.bind(this),returnError:m.returnError.bind(this),returnData:m.returnData.bind(this),returnNotFound:m.returnNotFound.bind(this)});return n.immediate&&n.immediate(),function(t=null,o=null){const i=r.isDefined(o),a=r.isDefined(t);n.beforeAll&&n.beforeAll(),i&&a?(n.beforeReturnErrorAndData&&n.beforeReturnErrorAndData(t,o),n.returnErrorAndData(t,o,e),n.afterReturnErrorAndData&&n.afterReturnErrorAndData(t,o)):i&&!a?(n.beforeReturnData&&n.beforeReturnData(o),n.returnData(o,e),n.afterReturnData&&n.afterReturnData(o)):!i&&a?(n.beforeReturnError&&n.beforeReturnError(t),n.returnError(t,e),n.afterReturnError&&n.afterReturnError(t)):i||a||(n.beforeReturnNotFound&&n.beforeReturnNotFound(),n.returnNotFound(e),n.afterReturnNotFound&&n.afterReturnNotFound()),n.afterAll&&n.afterAll()}}create(e,t,n){const o=e.body;r.isNotDefined(o)?m.returnError({title:"Erreur de paramètre",message:"Le corps de la requete ne peut pas être null ou indefini."},this._useNext?n:t):r.isArray(o)?r.isEmptyArray(o)?m.returnError({title:"Erreur de paramètre",message:"Le tableau d'objet de la requete ne peut pas être vide."},this._useNext?n:t):this._createMany(o,t,n):r.isObject(o)?r.isEmptyObject(o)?m.returnError({title:"Erreur de paramètre",message:"L'objet de la requete ne peut pas être vide."},this._useNext?n:t):this._createOne(o,t,n):m.returnError({title:"Erreur de paramètre",message:"Le type de donnée de la requete est invalide. Les paramètres valides sont objet ou un tableau d'objet."},this._useNext?n:t)}_createOne(){}_createMany(){}read(e,t,n){const o=e.params.id,i=e.body,a=r.isDefined(i),s=a?i.ids:null,c=a?i.query:null,u=a?i.projection:null;r.isDefined(o)?r.isNotString(o)?m.returnError({title:"Erreur de paramètre",message:"L'identifiant devrait être une chaine de caractères."},this._useNext?n:t):r.isEmptyString(o)||r.isBlankString(o)?m.returnError({title:"Erreur de paramètre",message:"L'identifiant ne peut pas être une chaine de caractères vide."},this._useNext?n:t):this._readOne(o,u,t,n):r.isDefined(s)?r.isNotArray(s)?m.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants devrait être un tableau de chaine de caractères."},this._useNext?n:t):r.isEmptyArray(s)?m.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants ne peut pas être vide."},this._useNext?n:t):this._readMany(s,u,t,n):r.isDefined(c)?r.isNotObject(c)?m.returnError({title:"Erreur de paramètre",message:"La requete devrait être un objet javascript."},this._useNext?n:t):r.isEmptyObject(c)?this._readAll(u,t,n):this._readWhere(c,u,t,n):m.returnError({title:"Erreur de paramètre",message:"La requete ne peut pas être null."},this._useNext?n:t)}_readOne(){}_readMany(){}_readWhere(){}_readAll(){}update(e,t,n){const o=e.params.id,i=e.body,a=r.isDefined(i),s=a?i.ids:null,c=a?i.query:null,u=a?i.update:null;r.isNotDefined(u)?m.returnError({title:"Erreur de paramètre",message:"La mise à jour a appliquer ne peut pas être null ou indefini."},this._useNext?n:t):r.isDefined(o)?r.isNotString(o)?m.returnError({title:"Erreur de paramètre",message:"L'identifiant devrait être une chaine de caractères."},this._useNext?n:t):r.isEmptyString(o)||r.isBlankString(o)?m.returnError({title:"Erreur de paramètre",message:"L'identifiant ne peut pas être une chaine de caractères vide."},this._useNext?n:t):this._updateOne(o,u,t,n):r.isDefined(s)?r.isNotArray(s)?m.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants devrait être un tableau de chaine de caractères."},this._useNext?n:t):r.isEmptyArray(s)?m.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants ne peut pas être vide."},this._useNext?n:t):this._updateMany(s,u,t,n):r.isDefined(c)?r.isNotObject(c)?m.returnError({title:"Erreur de paramètre",message:"La requete devrait être un objet javascript."},this._useNext?n:t):r.isEmptyObject(c)?this._updateAll(u,t,n):this._updateWhere(c,u,t,n):m.returnError({title:"Erreur de paramètre",message:"La requete ne peut pas être vide."},this._useNext?n:t)}_updateOne(){}_updateMany(){}_updateWhere(){}_updateAll(){}delete(e,t,n){const o=e.params.id,i=e.body,a=r.isDefined(i),s=a?i.ids:null,c=a?i.query:null;r.isDefined(o)?r.isNotString(o)?m.returnError({title:"Erreur de paramètre",message:"L'identifiant devrait être une chaine de caractères."},this._useNext?n:t):r.isEmptyString(o)||r.isBlankString(o)?m.returnError({title:"Erreur de paramètre",message:"L'identifiant ne peut pas être une chaine de caractères vide."},this._useNext?n:t):this._deleteOne(o,t,n):r.isDefined(s)?r.isNotArray(s)?m.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants devrait être un tableau de chaine de caractères."},this._useNext?n:t):r.isEmptyArray(s)?m.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants ne peut pas être vide."},this._useNext?n:t):this._deleteMany(s,t,n):r.isDefined(c)?r.isNotObject(c)?m.returnError({title:"Erreur de paramètre",message:"La requete devrait être un objet javascript."},this._useNext?n:t):r.isEmptyObject(c)?this._deleteAll(t,n):this._deleteWhere(c,t,n):m.returnError({title:"Erreur de paramètre",message:"La requete ne peut pas être vide."},this._useNext?n:t)}_deleteOne(){}_deleteMany(){}_deleteWhere(){}_deleteAll(){}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class f extends s.Writable{constructor(e){super(e);const t=e.bufferSize||i.kStringMaxLength;this.memoryBuffer=Buffer.alloc(t),this.offset=0}_final(e){e()}_write(e,t,r){const n=Buffer.isBuffer(e)?e:new Buffer(e,t);for(let e=0,t=n.length;e<t;e++)this.memoryBuffer[this.offset]=n[e],this.offset++;r()}_writev(e,t){for(let t=0,r=e.length;t<r;t++)this.memoryBuffer=Buffer.concat([this.memoryBuffer,e[t]]);t()}_releaseMemory(){this.memoryBuffer=null}toArrayBuffer(){const e=this.memoryBuffer,t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;++t)r[t]=e[t];return this._releaseMemory(),t}toJSON(){return JSON.parse(this.toString())}toString(){const e=this.memoryBuffer.toString();return this._releaseMemory(),e}}class h{constructor(e={}){const t={dumpType:h.DumpType.ArrayBuffer,...e};this.dumpType=t.dumpType,this._isProcessing=!1,this._queue=[]}get dumpType(){return this._dumpType}set dumpType(e){if(r.isNull(e))throw new TypeError("Dump type cannot be null ! Expect a non empty string.");if(r.isUndefined(e))throw new TypeError("Dump type cannot be undefined ! Expect a non empty string.");this._dumpType=e}setDumpType(e){return this.dumpType=e,this}convert(e,t,r,n,o){e?(this._queue.push({file:e,parameters:t,onSuccess:r,onProgress:n,onError:o}),this._processQueue()):o("File cannot be null or empty, aborting file convertion !!!")}_processQueue(){if(0===this._queue.length||this._isProcessing)return;this._isProcessing=!0;const e=this,t=this._queue.shift(),n=t.file,o=t.parameters,i=t.onSuccess,a=t.onProgress,s=t.onError;if(r.isString(n))e._dumpFileInMemoryAs(e._dumpType,n,o,c,d,l);else{const t=n.data;switch(e._dumpType){case h.DumpType.ArrayBuffer:{const e=t.length,r=new ArrayBuffer(e),n=new Uint8Array(r);for(let r=0;r<e;++r)n[r]=t[r];c(r)}break;case h.DumpType.JSON:c(JSON.parse(t.toString()));break;case h.DumpType.String:c(t.toString());break;default:throw new RangeError(`Invalid switch parameter: ${e._dumpType}`)}}function c(t){e._convert(t,o,u,d,l)}function u(t){i(t),e._isProcessing=!1,e._processQueue()}function d(e){a(e)}function l(t){s(t),e._isProcessing=!1,e._processQueue()}}_dumpFileInMemoryAs(e,t,r,n,o,i){let s=!1;const c=a.createReadStream(t);c.on("error",e=>{s=!0,i(e)});const u=parseInt(r.fileSize),d=new f({bufferSize:u});d.on("error",e=>{s=!0,i(e)}),d.on("finish",()=>{if(!s){switch(e){case h.DumpType.ArrayBuffer:n(d.toArrayBuffer());break;case h.DumpType.String:n(d.toString());break;case h.DumpType.JSON:n(d.toJSON());break;default:throw new RangeError(`Invalid switch parameter: ${e}`)}c.unpipe(),c.close(),d.end()}}),c.pipe(d)}_convert(){}}h.MAX_FILE_SIZE=67108864,h.DumpType=Object.freeze({ArrayBuffer:0,String:1,JSON:2});
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
class g{static _registerRoutesTo(e,t,r,n,o){for(let i=0,a=o.length;i<a;i++){const a=o[i],s=new(n.get(a.controller.name))({driver:e,...a.controller.options}),c=r({mergeParams:!0});console.log(`\tAdd controller for base route: ${a.route}`),t.use(a.route,g._populateRouter(c,s,a.controller.can))}}static _populateRouter(e,t,r={}){for(let n in r){const o=r[n];console.log(`\t\tMap route ${o.over} on (${o.on}) to ${t.constructor.name}.${n} method.`),e[o.on](o.over,t[n].bind(t))}return e}constructor(e={}){const t={controllers:new Map,descriptors:[],...e};this.controllers=t.controllers,this.descriptors=t.descriptors,this.__dirname=void 0}get controllers(){return this._controllers}set controllers(e){if(r.isNull(e))throw new TypeError("Controllers cannot be null ! Expect a map of controller.");if(r.isUndefined(e))throw new TypeError("Controllers cannot be undefined ! Expect a map of controller.");if(!(e instanceof Map))throw new TypeError(`Controllers cannot be an instance of ${e.constructor.name} ! Expect a map of controller.`);this._controllers=e}get descriptors(){return this._descriptors}set descriptors(e){if(r.isNull(e))throw new TypeError("Descriptors cannot be null ! Expect an array of POJO.");if(r.isUndefined(e))throw new TypeError("Descriptors cannot be undefined ! Expect an array of POJO.");this._descriptors=e}addController(e){return this._controllers.set(e.name,e),this}addDescriptor(e){return this._descriptors.push(e),this}beforeRegisterRoutes(){}registerTo(e,t,r){this.beforeRegisterRoutes(e),g._registerRoutesTo(e,t,r,this._controllers,this._descriptors)}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TMongooseController
 * @classdesc The TMongooseController is the base class to perform CRUD operations on the database
 */
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
class p extends t.TAbstractFileConverter{constructor(){super({dumpType:t.TAbstractFileConverter.DumpType.ArrayBuffer})}_convert(e,t,r,n,o){super._convert(e,t,r,n,o);try{r((new u.ColladaLoader).parse(e))}catch(e){o(e)}}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * From:
 * https://www.clicketyclick.dk/databases/xbase/format/db2_dbf.html#DBII_DBF_STRUCT
 * http://web.archive.org/web/20150323061445/http://ulisse.elettra.trieste.it/services/doc/dbase/DBFstruct.htm
 * http://www.dbase.com/Knowledgebase/INT/db7_file_fmt.htm
 *
 * @class Todo...
 * @classdesc Todo...
 * @example Todo...
 *
 */const v=Object.freeze({FoxPro:48,FoxPro_Autoincrement:49,dBASE_II:2,FoxPro_Var:50,dBASE_III_plus:3,dBASE_III_plus_memo:131,dBASE_IV_SQL_table:67,dBASE_IV_SQL_system:99,dBASE_IV_memo:139,dBASE_IV_memo_SQL_table:203,FoxBase:251,dBase_v_7:4,FoxPro_2_x:245,HiPerSix_memo:229}),y=Object.freeze({Binary:"B",Character:"C",Date:"D",Numeric:"N",Logical:"L",Memo:"M",Timestamp:"@",Long:"I",Autoincrement:"+",Float:"F",Double:"O",OLE:"G"});function S(e=u.DefaultLoadingManager,t=d.DefaultLogger){this.manager=e,this.logger=t,this.reader=new d.TBinaryReader}Object.assign(S,{Terminator:13,DeletedRecord:26,YearOffset:1900}),Object.assign(S.prototype,{load(e,t,r,n){const o=this,i=new u.FileLoader(o.manager);i.setResponseType("arraybuffer"),i.load(e,e=>{t(o.parse(e))},r,n)},parse(e){this.reader.setEndianess(d.Endianness.Big).setBuffer(e);const t=this.reader.getInt8();if(!this._isValidVersion(t))return this.logger.error(`DBFLoader: Invalid version number: ${t}`),null;const r=this._parseHeader(t);return{header:r,datas:this._parseDatas(t,r)}},_isValidVersion:e=>Object.values(v).includes(e),_parseHeader(e){let t={};switch(e){case v.FoxPro:case v.FoxPro_Autoincrement:case v.FoxPro_Var:case v.dBASE_II:t=this._parseHeaderV2();break;case v.dBASE_III_plus:case v.dBASE_III_plus_memo:t=this._parseHeaderV2_5();break;case v.dBASE_IV_memo:case v.dBASE_IV_memo_SQL_table:case v.dBASE_IV_SQL_system:case v.dBASE_IV_SQL_table:t=this._parseHeaderV3();break;case v.dBase_v_7:case v.FoxPro_2_x:case v.HiPerSix_memo:t=this._parseHeaderV4();break;default:throw new RangeError(`Invalid version parameter: ${e}`)}return this.reader.getUint8()!==S.Terminator&&this.logger.error("DBFLoader: Invalid terminator after field descriptors !!!"),t},_parseHeaderV2(){const e=this.reader.getInt16(),t=this.reader.getInt8()+S.YearOffset,r=this.reader.getInt8(),n=this.reader.getInt8(),o=this.reader.getInt16();let i=[],a=void 0,s=void 0,c=void 0,u=void 0,d=void 0;for(let t=0;t<e;t++)a=this.reader.getString(11),s=this.reader.getChar(),c=this.reader.getUint8(),u=this.reader.getInt16(),d=this.reader.getInt8(),i.push({name:a,type:s,length:c,memoryAddress:u,decimalCount:d});return{numberOfRecords:e,year:t,month:r,day:n,lengthOfEachRecords:o,fields:i}},_parseHeaderV2_5(){const e=this.reader.getInt8()+S.YearOffset,t=this.reader.getInt8(),r=this.reader.getInt8();this.reader.setEndianess(d.Endianness.Little);const n=this.reader.getInt32(),o=this.reader.getInt16(),i=this.reader.getInt16();this.reader.setEndianess(d.Endianness.Big),this.reader.skipOffsetOf(20);let a=[],s=void 0,c=void 0,u=void 0,l=void 0,m=void 0,f=void 0,h=void 0;for(let e=0;e<n;e++)s=this.reader.getString(11),c=this.reader.getChar(),l=this.reader.getInt32(),u=this.reader.getUint8(),m=this.reader.getUint8(),this.reader.skipOffsetOf(2),f=this.reader.getInt8(),this.reader.skipOffsetOf(2),h=this.reader.getInt8(),this.reader.skipOffsetOf(1),a.push({name:s,type:c,length:u,memoryAddress:l,decimalCount:m,workAreaId:f,MDXFlag:h});return{year:e,month:t,day:r,numberOfRecords:n,numberOfByteInHeader:o,numberOfByteInRecord:i,fields:a}},_parseHeaderV3(){const e=this.reader.getInt8()+S.YearOffset,t=this.reader.getInt8(),r=this.reader.getInt8();this.reader.setEndianess(d.Endianness.Little);const n=this.reader.getInt32(),o=this.reader.getInt16(),i=this.reader.getInt16();this.reader.setEndianess(d.Endianness.Big),this.reader.skipOffsetOf(2);const a=this.reader.getInt8(),s=this.reader.getInt8();this.reader.skipOffsetOf(12);const c=this.reader.getInt8(),u=this.reader.getInt8();this.reader.skipOffsetOf(2);let l=[],m=void 0,f=void 0,h=void 0,g=void 0,p=void 0,v=void 0;for(;this.reader.getOffset()<o-1;)m=this.reader.getString(11),f=this.reader.getChar(),this.reader.skipOffsetOf(4),h=this.reader.getUint8(),g=this.reader.getUint8(),this.reader.skipOffsetOf(2),p=this.reader.getInt8(),this.reader.skipOffsetOf(10),v=this.reader.getInt8(),l.push({name:m,type:f,length:h,decimalCount:g,workAreaId:p,MDXFieldFlag:v});return{year:e,month:t,day:r,numberOfRecords:n,numberOfByteInHeader:o,numberOfByteInRecord:i,incompleteTransactionFlag:a,encryptionFlag:s,MDXFlag:c,languageDriverId:u,fields:l}},_parseHeaderV4(){const e=this.reader.getInt8()+S.YearOffset,t=this.reader.getInt8(),r=this.reader.getInt8();this.reader.setEndianess(d.Endianness.Little);const n=this.reader.getInt32(),o=this.reader.getInt16(),i=this.reader.getInt16();this.reader.setEndianess(d.Endianness.Big),this.reader.skipOffsetOf(2);const a=this.reader.getInt8(),s=this.reader.getInt8();this.reader.skipOffsetOf(12);const c=this.reader.getInt8(),u=this.reader.getInt8();this.reader.skipOffsetOf(2);const l=this.reader.getString(32);this.reader.skipOffsetOf(4);let m=[],f=void 0,h=void 0,g=void 0,p=void 0,v=void 0,y=void 0;for(let e=0;e<n;e++)f=this.reader.getString(32),h=this.reader.getChar(),g=this.reader.getUint8(),p=this.reader.getUint8(),this.reader.skipOffsetOf(2),v=this.reader.getInt8(),this.reader.skipOffsetOf(2),y=this.reader.getInt32(),this.reader.skipOffsetOf(4),m.push({name:f,type:h,length:g,decimalCount:p,MDXFieldFlag:v,nextAutoincrementValue:y});return{year:e,month:t,day:r,numberOfRecords:n,numberOfByteInHeader:o,numberOfByteInRecord:i,incompleteTransactionFlag:a,encryptionFlag:s,MDXFlag:c,languageDriverId:u,languageDriverName:l,fields:m}},_parseDatas(e,t){const r=t.numberOfRecords,n=t.fields;let o=[],i=null,a=null;for(let e=0;e<r;e++){i={},i.deleted=this.reader.getUint8()===S.DeletedRecord;for(let e=0,t=n.length;e<t;e++)switch(a=n[e],a.type){case y.Binary:{const e=this.reader.getString(a.length);i[a.name]=parseInt(e)}break;case y.Numeric:{const e=this.reader.getString(a.length);i[a.name]=parseInt(e)}break;case y.Character:case y.Date:i[a.name]=this.reader.getString(a.length);break;case y.Logical:{const e=this.reader.getChar().toLowerCase();i[a.name]="t"===e||"y"===e||"f"!==e&&"n"!==e&&null}break;case y.Memo:i[a.name]=this.reader.getString(a.length);break;case y.Timestamp:break;case y.Long:case y.Autoincrement:i[a.name]=this.reader.getInt32();break;case y.Float:{const e=this.reader.getString(a.length);i[a.name]=parseInt(e)}break;case y.Double:i[a.name]=this.reader.getFloat64();break;case y.OLE:i[a.name]=this.reader.getString(a.length);break;default:throw new RangeError(`Invalid data type parameter: ${a.type}`)}o.push(i)}return o},_parseFieldProperties(){const e=this.reader.getInt16(),t=this.reader.getInt16(),r=this.reader.getInt16(),n=this.reader.getInt16(),o=this.reader.getInt16(),i=this.reader.getInt16(),a=this.reader.getInt16(),s=this.reader.getInt16();let c=[];for(let t=0;t<e;t++)c.push(this._getStandardProperties());let u=[];for(let e=0;e<r;e++)u.push(this._getCustomProperties());let d=[];for(let e=0;e<o;e++)d.push(this._getReferentialIntegrityProperties());return{numberOfStandardProperties:e,startOfStandardPropertiesDescriptor:t,numberOfCustomProperties:r,startOfCustomPropertiesDescriptor:n,numberOfReferentialIntegrityProperties:o,startOfReferentialIntegrityDescriptor:i,startOfData:a,sizeOfPropertiesStructure:s,standardProperties:c,customProperties:u,referentialIntegrityProperties:d}},_getStandardProperties(){const e=this.reader.getInt16(),t=this.reader.getInt16(),r=this.reader.getInt8(),n=this.reader.getInt8(),o=this.reader.getInt8();return this.reader.skipOffsetOf(4),{generationalNumber:e,tableFieldOffset:t,propertyDescribed:r,type:n,isConstraint:o,offsetFromStart:this.reader.getInt16(),widthOfDatabaseField:this.reader.getInt16()}},_getCustomProperties(){const e=this.reader.getInt16(),t=this.reader.getInt16(),r=this.reader.getInt8();return this.reader.skipOffsetOf(1),{generationalNumber:e,tableFieldOffset:t,type:r,offsetFromStartOfName:this.reader.getInt16(),lengthOfName:this.reader.getInt16(),offsetFromStartOfData:this.reader.getInt16(),lengthOfData:this.reader.getInt16()}},_getReferentialIntegrityProperties(){return{databaseState:this.reader.getInt8(),sequentialNumberRule:this.reader.getInt16(),offsetOfTheRIRuleName:this.reader.getInt16(),sizeOfTheRIRuleName:this.reader.getInt16(),offsetOfNameOfForeignTable:this.reader.getInt16(),sizeOfNameOfForeignTable:this.reader.getInt16(),stateBehaviour:this.reader.getInt8(),numberOfFieldsInLinkingKey:this.reader.getInt16(),offsetOfLocalTableTagName:this.reader.getInt16(),sizeOfTheLocalTableTagName:this.reader.getInt16(),offsetOfForeignTableTagName:this.reader.getInt16(),sizeOfTheForeignTableTagName:this.reader.getInt16()}}});
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
class M extends t.TAbstractFileConverter{constructor(){super({dumpType:t.TAbstractFileConverter.DumpType.ArrayBuffer})}_convert(e,t,r,n,o){super._convert(e,t,r,n,o);try{r((new S).parse(e))}catch(e){o(e)}}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class b extends t.TAbstractFileConverter{constructor(){super({dumpType:t.TAbstractFileConverter.DumpType.ArrayBuffer})}_convert(e,t,r,n,o){super._convert(e,t,r,n,o);try{r((new u.FBXLoader).parse(e))}catch(e){o(e)}}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class F extends t.TAbstractFileConverter{constructor(){super({dumpType:t.TAbstractFileConverter.DumpType.JSON})}_convert(e,t,r,n,o){super._convert(e,t,r,n,o);try{r((new u.ObjectLoader).parse(e))}catch(e){o(e)}}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class _ extends t.TAbstractFileConverter{constructor(){super({dumpType:t.TAbstractFileConverter.DumpType.String})}_convert(e,t,r,n,o){super._convert(e,t,r,n,o);try{r((new u.MTLLoader).parse(e))}catch(e){o(e)}}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class w extends t.TAbstractFileConverter{constructor(){super({dumpType:t.TAbstractFileConverter.DumpType.JSON})}_convert(e,t,r,n,o){super._convert(e,t,r,n,o);try{r((new u.OBJLoader2).parse(e))}catch(e){o(e)}}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * This class allow to split any geometries type during runtime.
 * Keeping normals and Uvs. It is really usefull to see inside mesh like building.
 *
 * Constructor parameter:
 *
 * size - the size of the square view
 *
 * @class Todo...
 * @classdesc Todo...
 * @example Todo...
 *
 */const T=Object.freeze({NullShape:0,Point:1,Polyline:3,Polygon:5,MultiPoint:8,PointZ:11,PolyLineZ:13,PolygonZ:15,MultiPointZ:18,PointM:21,PolylineM:23,PolygonM:25,MultiPointM:28,MultiPatch:31});function N(e,t){let r=t[0],n=t[1],o=-1;for(let i=0,a=e.length,s=a-1;i<a;s=i++){const a=e[i],c=a[0],u=a[1],d=e[s],l=d[0],m=d[1];B(a,d,t)?o=0:u>n!=m>n&&r<(l-c)*(n-u)/(m-u)+c&&(o=-o)}return o}function B(e,t,r){var n=r[0]-e[0],o=r[1]-e[1];if(0===n&&0===o)return!0;var i=t[0]-e[0],a=t[1]-e[1];if(0===i&&0===a)return!1;var s=(n*i+o*a)/(i*i+a*a);return!(s<0||s>1)&&(0===s||1===s||s*i===n&&s*a===o)}function O(e=u.DefaultLoadingManager,t=d.DefaultLogger){this.manager=e,this.logger=t,this.globalOffset=new u.Vector3,this.worldAxis={from:"zUp",to:"zForward"},this._reader=new d.TBinaryReader}Object.assign(O,{FileCode:9994,MinFileLength:100,MinVersion:1e3}),Object.assign(O.prototype,{load(e,t,r,n){const o=this,i=new u.FileLoader(o.manager);i.setResponseType("arraybuffer"),i.load(e,e=>{t(o.parse(e))},r,n)},parse(e){this._reader.setEndianess(d.Endianness.Big).setBuffer(e);const t=this._parseHeader();if(t.fileCode!==O.FileCode)return this.logger.error("SHPLoader: Invalide Shape file code !"),null;if(t.fileLength<O.MinFileLength)return this.logger.error("SHPLoader: Shape file have an incorrect length !"),null;if(!Object.values(T).includes(t.shapeType))return this.logger.error("SHPLoader: Shape file have an incorrect shape type !"),null;t.version<O.MinVersion&&this.logger.warn("SHPLoader: Version of shape file below than 1000 could be incorrectly parsed !");const r=this._parseDatas(t);return this._convertToObjects(r)},_parseHeader(){const e=this._reader.getInt32();this._reader.skipOffsetOf(20);const t=this._reader.getInt32();this._reader.setEndianess(d.Endianness.Little);const r=this._reader.getInt32(),n=this._reader.getInt32(),o=this._reader.getInt32(),i=this._reader.getInt32();return{fileCode:e,fileLength:t,version:r,shapeType:n,boundingBox:{xMin:o,xMax:this._reader.getInt32(),yMin:i,yMax:this._reader.getInt32(),zMin:this._reader.getInt32(),zMax:this._reader.getInt32(),mMin:this._reader.getInt32(),mMax:this._reader.getInt32()}}},_parseDatas(e){this._reader.skipOffsetTo(100);let t=[],r=void 0,n=void 0,o=void 0;for(;!this._reader.isEndOfFile();)switch(r=this._parseRecordHeader(),n=this._reader.getOffset()+2*r.contentLength,this._reader.setEndianess(d.Endianness.Little),e.shapeType){case T.NullShape:this._reader.skipOffsetTo(n);break;case T.Point:case T.PointZ:case T.PointM:for(;this._reader.getOffset()<n;)o=this._parsePoint(),o&&t.push(o);break;case T.Polyline:case T.PolyLineZ:case T.PolylineM:for(;this._reader.getOffset()<n;)o=this._parsePolyLine(),o&&t.push(o);break;case T.Polygon:case T.PolygonZ:case T.PolygonM:for(;this._reader.getOffset()<n;)o=this._parsePolyLine(),o&&t.push(o);break;case T.MultiPoint:case T.MultiPointZ:case T.MultiPointM:for(;this._reader.getOffset()<n;)o=this._parseMultiPoint(),o&&t.push(o);break;case T.MultiPatch:for(;this._reader.getOffset()<n;)o=this._parseMultiPatch(),o&&t.push(o);break;default:this.logger.error(`SHPLoader: Invalid switch parameter: ${e.shapeType}`)}return t},_parseRecordHeader(){return this._reader.setEndianess(d.Endianness.Big),{recordNumber:this._reader.getInt32(),contentLength:this._reader.getInt32()}},_parsePoint(){const e=this._reader.getInt32();return e===T.NullShape?null:{shapeType:e,x:this._reader.getFloat64(),y:this._reader.getFloat64()}},_parsePolyLine(){const e=this._reader.getInt32();if(e===T.NullShape)return null;const t={xMin:this._reader.getFloat64(),yMin:this._reader.getFloat64(),xMax:this._reader.getFloat64(),yMax:this._reader.getFloat64()},r=this._reader.getInt32(),n=this._reader.getInt32(),o=new Array(r);for(let e=0;e<r;e++)o[e]=this._reader.getInt32();const i=new Array(n);for(let e=0;e<n;e++)i[e]={x:this._reader.getFloat64(),y:this._reader.getFloat64()};return{shapeType:e,boundingBox:t,numberOfParts:r,numberOfPoints:n,parts:o,points:i}},_parsePolygon(){const e=this._reader.getInt32();if(e===T.NullShape)return null;const t={xMin:this._reader.getFloat64(),yMin:this._reader.getFloat64(),xMax:this._reader.getFloat64(),yMax:this._reader.getFloat64()},r=this._reader.getInt32(),n=this._reader.getInt32();let o=new Array(r);for(let e=0;e<r;e++)o[e]=this._reader.getInt32();let i=new Array(n);for(let e=0;e<n;e++)i[e]={x:this._reader.getFloat64(),y:this._reader.getFloat64()};const a=[],s=[];return o.forEach((e,t)=>{const r=i.slice(e,o[t+1]);!function(e){if((t=e.length)<4)return!1;for(var t,r=0,n=e[t-1][1]*e[0][0]-e[t-1][0]*e[0][1];++r<t;)n+=e[r-1][1]*e[r][0]-e[r-1][0]*e[r][1];return n>=0}(r)?s.push(r):a.push(r)}),s.forEach(e=>{a.some(t=>{if(function(e,t){let r=0,n=t.length;do{if(N(e,t[r])>0)return!0}while(++r<n);return!1}(t[0],e))return t.push(e),!0})||a.push([e])}),{shapeType:e,boundingBox:t,numberOfParts:r,numberOfPoints:n,parts:o,polygons:a}},_parseMultiPoint(){const e=this._reader.getInt32();if(e===T.NullShape)return null;const t={xMin:this._reader.getFloat64(),xMax:this._reader.getFloat64(),yMin:this._reader.getFloat64(),yMax:this._reader.getFloat64()},r=this._reader.getInt32(),n=new Array(r);for(let e=0;e<r;e++)n.push([this._reader.getFloat64(),this._reader.getFloat64()]);return{shapeType:e,boundingBox:t,numberOfPoints:r,points:n}},_parseMultiPatch(){const e=this._reader.getInt32();return e===T.NullShape?null:{shapeType:e}},_convertToObjects(e){let t=[];for(let t=0,o=e.length;t<o;t++){let o=e[t];o.shapeType!==T.Polygon&&o.shapeType!==T.PolygonZ&&o.shapeType!==T.PolygonM||(o.points&&Array.isArray(o.points[0])?r(o.points):n(o.points))}function r(e){for(let t=0,o=e.length;t<o;t++){let o=e[t];o?Array.isArray(o[0])?r(o):n(o):this.logger.log("no array, oups !")}}function n(e){t.push(new u.Shape(e))}return t}});
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
class D extends t.TAbstractFileConverter{constructor(){super({dumpType:t.TAbstractFileConverter.DumpType.ArrayBuffer})}_convert(e,t,r,n,o){super._convert(e,t,r,n,o);try{r((new O).parse(e))}catch(e){o(e)}}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class E extends t.TAbstractFileConverter{constructor(){super({dumpType:t.TAbstractFileConverter.DumpType.JSON})}_convert(e,t,r,n,o){super._convert(e,t,r,n,o);try{r((new u.STLLoader).parse(e))}catch(e){o(e)}}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class x extends t.TAbstractFileConverter{constructor(){super({dumpType:t.TAbstractFileConverter.DumpType.ArrayBuffer})}_convert(e,t,r,n,o){super._convert(e,t,r,n,o);try{r((new u.TDSLoader).parse(e))}catch(e){o(e)}}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class I extends t.TAbstractDataInserter{constructor(e={}){super(e),this.mergeStrategy="add"}static _arrayify(e){let t=[];return r.isDefined(e)&&(t=r.isArray(e)?e:[e]),t}async _save(e,t,n,o,i){const a=I._arrayify(e);if(r.isEmptyArray(a))return void i("No data to save in database. Abort insert !");const s=a.map(e=>e.name);console.log(`ThreeToMongoDB: Saving ${s}`),t.mergeStrategy&&(this.mergeStrategy=t.mergeStrategy);try{const e=t.parentId;let o=null,s=null;if(r.isDefined(e)){const n=this._readOneDocument("Objects3D",{_id:e});if(r.isNull(n))return void i(`Unable to retrieve parent with id (${t.parentId}). Abort insert !`);if("add"===this.mergeStrategy)o=await this._parseObjects(a,e),s=r.isDefined(o)?o.filter(e=>e).map(e=>e._id):[],this._updateDocument(n,{$addToSet:{children:s}});else if("replace"===this.mergeStrategy){const t=this._readManyDocument("Objects3D",{parent:e}),i=a.map(e=>e.uuid),c=t.filter(e=>!i.includes(e.uuid));this._removeChildrenDocuments(c),o=await this._parseObjects(a,e),s=r.isDefined(o)?o.filter(e=>e).map(e=>e._id):[],this._updateDocument(n,{$set:{children:s}})}}else o=await this._parseObjects(a,null),s=r.isDefined(o)?o.filter(e=>e).map(e=>e._id):[];console.log(`ThreeToMongoDB: Saved ${s}`),n()}catch(e){i(e)}}async _parseObjects(e=[],t=null){const n=I._arrayify(e);if(r.isEmptyArray(n))return null;const o=[];let i=null;for(let e=0,r=n.length;e<r;e++)i=this._parseObject(n[e],t),o.push(i);return Promise.all(o)}async _parseObject(e,t=null){if(r.isNotDefined(e))return null;const n=e.type,o=e.name,i=e.geometry,a=I._arrayify(e.children),s=I._arrayify(e.material);if(r.isDefined(i)&&r.isEmptyArray(a))if(i.isGeometry){const e=i.vertices;if(r.isNotDefined(e)||r.isEmptyArray(e))return console.error(`Leaf object ${o} have a geometry that doesn't contain vertices ! Skip it.`),null}else{if(!i.isBufferGeometry)return console.error(`Object ${o} contain an unknown/unmanaged geometry of type ${i.type} ! Skip it.`),null;{const e=i.attributes;if(r.isNotDefined(e))return console.error(`Buffer geometry of ${o} doesn't contain attributes ! Skip it.`),null;const t=e.position;if(r.isNotDefined(t)||0===t.count)return console.error(`Leaf object ${o} have a buffer geometry that doesn't contain position attribute ! Skip it.`),null}}let c=null;if(I.AvailableLineTypes.includes(n)){if(r.isNotDefined(i))return console.error(`Missing geometry for object ${e.name} of type ${n}. Only Sprite can contains material without geometry ! Skip it.`),null;c=I.AvailableLineMaterialTypes}else if(I.AvailablePointTypes.includes(n)){if(r.isNotDefined(i))return console.error(`Missing geometry for object ${e.name} of type ${n}. Only Sprite can contains material without geometry ! Skip it.`),null;c=I.AvailablePointMaterialTypes}else I.AvailableSpriteTypes.includes(n)&&(c=I.AvailableSpriteMaterialTypes);if(c)for(let e=0,t=s.length;e<t;e++){const t=s[e].type;if(!c.includes(t))return console.error(`Object ${o} of type ${n}, contain an invalid material of type ${t} ! Skip it.`),null}const u=this._getOrCreateDocuments(i),d=r.isDefined(u)?u.filter(e=>e).map(e=>e._id).pop():null,l=this._getOrCreateDocuments(s),m=r.isDefined(l)?l.filter(e=>e).map(e=>e._id):[];let f=this._readOneDocument(n,{uuid:e.uuid,parent:t});if(r.isDefined(f))if("add"===this.mergeStrategy){const e=this._parseObjects(a,f._id),t=r.isDefined(e)?e.filter(e=>e).map(e=>e._id):[];this._updateDocument(f,{$addToSet:{children:t}})}else if("replace"===this.mergeStrategy){const e=this._readManyDocument("Objects3D",{parent:f._id}),t=a.map(e=>e.uuid),n=e.filter(e=>!t.includes(e.uuid));this._removeChildrenDocuments(n);const o=this._parseObjects(a,f._id),i=r.isDefined(o)?o.filter(e=>e).map(e=>e._id):[];this._updateDocument(f,{$set:{children:i,geometry:d,material:m}})}else console.error(`Unknown/Unmanaged merge srategy ${this.mergeStrategy}`);else{e.parent=t,e.children=[],e.geometry=d,e.material=m,f=this._createDocument(e);const n=this._parseObjects(a,f._id),o=r.isDefined(n)?n.filter(e=>e).map(e=>e._id):[];this._updateDocument(f,{$set:{children:o,geometry:d,material:m}})}return f}_getOrCreateDocuments(e=[]){const t=I._arrayify(e);if(r.isEmptyArray(t))return null;const n=[];for(let e=0,r=t.length;e<r;e++){const r=this._getOrCreateDocument(t[e]);n.push(r)}return Promise.all(n)}_getOrCreateDocument(e){if(r.isNotDefined(e))return null;let t=this._readOneDocument(e.type,{uuid:e.uuid});return t=r.isDefined(t)?this._updateDocument(t,e):this._createDocument(e),t}_createDocuments(e=[]){const t=I._arrayify(e);if(r.isEmptyArray(t))return null;const n=[];for(let e=0,r=t.length;e<r;e++){const r=this._createDocument(t[e]);n.push(r)}return n}async _createDocument(e){if(r.isNotDefined(e))return null;const t=this._driver.model(e.type);return(await t(e).save())._doc}async _readOneDocument(e,t){if(r.isNotDefined(e)||r.isNotDefined(t))return null;const n=await this._driver.model(e).findOne(t).exec();return r.isDefined(n)?n._doc:null}async _readManyDocument(e,t){return r.isNotDefined(e)||r.isNotDefined(t)?null:await this._driver.model(e).find(t).exec().map(e=>e._doc)}_updateDocuments(e=[],t,n){const o=I._arrayify(e);if(r.isEmptyArray(o))return null;const i=[];for(let e=0,r=o.length;e<r;e++){const r=this._updateDocument(o[e],t,n);i.push(r)}return i}async _updateDocument(e,t,n){return r.isNotDefined(e)?null:await this._driver.model(e.type).findByIdAndUpdate(e._id,t,n).exec()}_deleteDocuments(e=[]){const t=I._arrayify(e);if(r.isEmptyArray(t))return null;const n=[];for(let e=0,r=t.length;e<r;e++){const r=this._deleteDocument(t[e]);n.push(r)}return n}async _deleteDocument(e){return r.isNotDefined(e)?null:await this._driver.model(e.type).findByIdAndDelete(e._id).exec()}_removeChildrenDocuments(e){for(let t=e.length-1;t>=0;t--)this._removeChildDocument(e[t])}_removeChildDocument(e){const t=this._readManyDocument("Objects3D",{parent:e._id});this._removeChildrenDocuments(t),this._removeOrphanGeometryWithId(e.geometry),this._removeOrphanMaterialsWithIds(e.material||[]),this._deleteDocument(e)}_removeOrphanGeometryWithId(e){if(r.isNotDefined(e))return;if(this._readManyDocument("Objects3D",{geometry:e}).length>1)return;const t=this._readOneDocument("Geometries",{_id:e});this._deleteDocument(t)}_removeOrphanMaterialsWithIds(e){const t=[];for(let r=0,n=e.length;r<n;r++){const n=e[r],o=this._removeOrphanMaterialWithId(n);t.push(o)}return t}_removeOrphanMaterialWithId(e){if(this._readManyDocument("Objects3D",{material:e}).length>1)return;const t=this._readOneDocument("Materials",{_id:e});this._deleteDocument(t)}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Object3D
 *
 * @description Todo...
 */
function A(){}I.AvailableCurveTypes=["Curve","ArcCurve","CatmullRomCurve3","CubicBezierCurve","CubicBezierCurve3","EllipseCurve","LineCurve","LineCurve3","QuadraticBezierCurve","QuadraticBezierCurve3","SplineCurve","CurvePath","Path","Shape"],I.AvailableLineTypes=["Line","LineLoop","LineSegments"],I.AvailableLineMaterialTypes=["LineBasicMaterial","LineDashedMaterial"],I.AvailablePointTypes=["Points"],I.AvailablePointMaterialTypes=["PointsMaterial"],I.AvailableSpriteTypes=["Sprite"],I.AvailableSpriteMaterialTypes=["SpriteMaterial"],A.getSchemaFrom=e=>(A._schema||A._createSchema(e),A._schema),A._createSchema=e=>{const t=e.Schema,r=t.Types,n=r.ObjectId,o=r.Mixed,i=r.Vector3,a=r.Quaternion,s=r.Matrix4,c=r.Euler;A._schema=new t({uuid:String,name:String,type:String,parent:n,children:[n],up:i,position:i,rotation:c,quaternion:a,scale:{type:i,default:{x:1,y:1,z:1}},modelViewMatrix:s,normalMatrix:s,matrix:s,matrixWorld:s,matrixAutoUpdate:Boolean,matrixWorldNeedsUpdate:Boolean,layers:{type:Number,set:e=>e.mask},visible:Boolean,castShadow:Boolean,receiveShadow:Boolean,frustumCulled:Boolean,renderOrder:Boolean,userData:{type:o,set:e=>function e(t){let r={};for(let n in t){if(!Object.prototype.hasOwnProperty.call(t,n))continue;let o=t[n];o.constructor===Object&&(o=e(o)),r[n.replace(/\./g,"")]=o}return r}(e)}},{collection:"objects",discriminatorKey:"type"})},A.getModelFrom=e=>(A._model||A._createModel(e),A._model),A._createModel=e=>{A._model=e.model("Objects3D",A.getSchemaFrom(e)),A._model.discriminator("Object3D",new e.Schema({}))},A.registerModelTo=e=>(A._model||A._createModel(e),e),A._schema=null,A._model=null;var C=Object.freeze({__proto__:null,Object3D:A});
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:j}=C;let L=void 0,P=void 0;function G(e){return L||function(e){const t=e.Schema;L=new t({})}(e),L}function $(e){const t=j.getModelFrom(e);P=t.discriminator("Audio",G(e))}var V={getSchemaFrom:G,getModelFrom:function(e){return P||$(e),P},registerModelTo:function(e){return P||$(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:R}=C;let U=void 0,k=void 0;function z(e){return U||function(e){const t=e.Schema;U=new t({})}(e),U}function H(e){const t=R.getModelFrom(e);k=t.discriminator("AudioListener",z(e))}var q={getSchemaFrom:z,getModelFrom:function(e){return k||H(e),k},registerModelTo:function(e){return k||H(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:W}=C;let Q=void 0,Z=void 0;function X(e){return Q||function(e){const t=e.Schema;Q=new t({})}(e),Q}function Y(e){const t=W.getModelFrom(e);Z=t.discriminator("PositionalAudio",X(e))}var J={getSchemaFrom:X,getModelFrom:function(e){return Z||Y(e),Z},registerModelTo:function(e){return Z||Y(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:K}=C;let ee=void 0,te=void 0;function re(e){return ee||function(e){const t=e.Schema;ee=new t({})}(e),ee}function ne(e){const t=K.getModelFrom(e);te=t.discriminator("ArrayCamera",re(e))}var oe={getSchemaFrom:re,getModelFrom:function(e){return te||ne(e),te},registerModelTo:function(e){return te||ne(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:ie}=C;let ae=void 0,se=void 0;function ce(e){return ae||function(e){const t=e.Schema;ae=new t({})}(e),ae}function ue(e){const t=ie.getModelFrom(e);se=t.discriminator("Camera",ce(e))}var de={getSchemaFrom:ce,getModelFrom:function(e){return se||ue(e),se},registerModelTo:function(e){return se||ue(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:le}=C;let me=void 0,fe=void 0;function he(e){return me||function(e){const t=e.Schema;me=new t({})}(e),me}function ge(e){const t=le.getModelFrom(e);fe=t.discriminator("CubeCamera",he(e))}var pe={getSchemaFrom:he,getModelFrom:function(e){return fe||ge(e),fe},registerModelTo:function(e){return fe||ge(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:ve}=C;let ye=void 0,Se=void 0;function Me(e){return ye||function(e){const t=e.Schema;ye=new t({})}(e),ye}function be(e){const t=ve.getModelFrom(e);Se=t.discriminator("OrthographicCamera",Me(e))}var Fe={getSchemaFrom:Me,getModelFrom:function(e){return Se||be(e),Se},registerModelTo:function(e){return Se||be(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:_e}=C;let we=void 0,Te=void 0;function Ne(e){return we||function(e){const t=e.Schema;we=new t({})}(e),we}function Be(e){const t=_e.getModelFrom(e);Te=t.discriminator("PerspectiveCamera",Ne(e))}var Oe={getSchemaFrom:Ne,getModelFrom:function(e){return Te||Be(e),Te},registerModelTo:function(e){return Te||Be(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Geometry
 *
 * @description Todo...
 */const{isInt8Array:De,isInt16Array:Ee,isInt32Array:xe,isFloat32Array:Ie,isFloat64Array:Ae,isUint8Array:Ce,isUint8ClampedArray:je,isUint16Array:Le,isUint32Array:Pe,isBigInt64Array:Ge,isBigUint64Array:$e}=n;let Ve=void 0;var Re={getSchemaFrom:function(e){return Ve||function(e){const t=e.Schema,r=t.Types.Mixed,n={Int8Array:0,Uint8Array:1,Uint8ClampedArray:2,Int16Array:3,Uint16Array:4,Int32Array:5,Uint32Array:6,Float32Array:7,Float64Array:8,BigInt64Array:9,BigUint64Array:10};Ve=new t({array:{type:Buffer,set:e=>{const t=e.length;let r=null,o=0;if(De(e)){r=Buffer.allocUnsafe(1+1*t),o=r.writeUInt8(n.Int8Array,o);for(let n=0;n<t;n++)o=r.writeInt8(e[n],o)}else if(Ce(e)){r=Buffer.allocUnsafe(1+1*t),o=r.writeUInt8(n.Uint8Array,o);for(let n=0;n<t;n++)o=r.writeUInt8(e[n],o)}else if(je(e)){r=Buffer.allocUnsafe(1+1*t),o=r.writeUInt8(n.Uint8ClampedArray,o);for(let n=0;n<t;n++)o=r.writeUInt8(e[n],o)}else if(Ee(e)){r=Buffer.allocUnsafe(1+2*t),o=r.writeUInt8(n.Int16Array,o);for(let n=0;n<t;n++)o=r.writeInt16BE(e[n],o)}else if(Le(e)){r=Buffer.allocUnsafe(1+2*t),o=r.writeUInt8(n.Uint16Array,o);for(let n=0;n<t;n++)o=r.writeUInt16BE(e[n],o)}else if(xe(e)){r=Buffer.allocUnsafe(1+4*t),o=r.writeUInt8(n.Int32Array,o);for(let n=0;n<t;n++)o=r.writeInt32BE(e[n],o)}else if(Pe(e)){r=Buffer.allocUnsafe(1+4*t),o=r.writeUInt8(n.Uint32Array,o);for(let n=0;n<t;n++)o=r.writeUInt32BE(e[n],o)}else if(Ie(e)){r=Buffer.allocUnsafe(1+4*t),o=r.writeUInt8(n.Float32Array,o);for(let n=0;n<t;n++)o=r.writeFloatBE(e[n],o)}else if(Ae(e)){r=Buffer.allocUnsafe(1+8*t),o=r.writeUInt8(n.Float64Array,o);for(let n=0;n<t;n++)o=r.writeDoubleBE(e[n],o)}else if(Ge(e)){r=Buffer.allocUnsafe(1+8*t),o=r.writeUInt8(n.BigInt64Array,o);for(let n=0;n<t;n++)o=r.writeDoubleBE(e[n],o)}else{if(!$e(e))throw new Error("Unable to determine the array type to bufferize.");r=Buffer.allocUnsafe(1+8*t),o=r.writeUInt8(n.BigUint64Array,o);for(let n=0;n<t;n++)o=r.writeDoubleBE(e[n],o)}return r}},count:Number,dynamic:Boolean,itemSize:Number,name:String,needsUpdate:Boolean,normalized:Boolean,updateRange:r,uuid:String,version:Number},{_id:!1,id:!1})}(e),Ve},getModelFrom:()=>null,registerModelTo:e=>e},Ue={BufferAttribute:Re};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/BufferGeometry
 *
 * @description Todo...
 */
const{BufferAttribute:ke}=Ue;let ze=void 0,He=void 0;function qe(e){return ze||function(e){const t=e.Schema,r=t.Types,n=r.Mixed,o=r.Vector3,i=ke.getSchemaFrom(e);ze=new t({uuid:String,name:String,type:String,index:i,attributes:{position:i,normal:i,color:i,uv:i},groups:n,boundingBox:{min:o,max:o},boundingSphere:{center:o,radius:Number},drawRange:n},{collection:"geometries",discriminatorKey:"type"})}(e),ze}function We(e){He=e.model("BufferGeometries",qe(e)),He.discriminator("BufferGeometry",new e.Schema({}))}var Qe={getSchemaFrom:qe,getModelFrom:function(e){return He||We(e),He},registerModelTo:function(e){return He||We(e),e}},Ze={BufferGeometry:Qe};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Geometry
 *
 * @description Todo...
 */
let Xe=void 0,Ye=void 0;function Je(e){return Xe||function(e){const t=e.Schema;Xe=new t({type:{type:String,default:"Curve"},arcLengthDivisions:Number},{collection:"curves",discriminatorKey:"type"})}(e),Xe}function Ke(e){Ye=e.model("Curves",Je(e)),Ye.discriminator("Curve",new e.Schema({}))}var et={getSchemaFrom:Je,getModelFrom:function(e){return Ye||Ke(e),Ye},registerModelTo:function(e){return Ye||Ke(e),e}},tt={Curve:et};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
const{Curve:rt}=tt;let nt=void 0,ot=void 0;function it(e){return nt||function(e){const t=e.Schema,r=new t({type:{type:String,default:"Curve"},arcLengthDivisions:Number},{id:!1,_id:!1});nt=new t({curves:[r],autoClose:{type:Boolean,default:!1}})}(e),nt}function at(e){const t=rt.getModelFrom(e);ot=t.discriminator("CurvePath",it(e))}var st={getSchemaFrom:it,getModelFrom:function(e){return ot||at(e),ot},registerModelTo:function(e){return ot||at(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Face3
 *
 * @description Todo...
 */let ct=void 0;var ut={getSchemaFrom:function(e){return ct||function(e){const t=e.Schema,r=t.Types,n=r.Color,o=r.Vector3;ct=new t({a:Number,b:Number,c:Number,normal:o,vertexNormals:[Number],color:n,vertexColors:[Number],materialIndex:Number},{_id:!1,id:!1})}(e),ct},getModelFrom:()=>null,registerModelTo:e=>e};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Geometry
 *
 * @description Todo...
 */let dt=void 0,lt=void 0;function mt(e){return dt||function(e){const t=ut.getSchemaFrom(e),r=e.Schema,n=r.Types.Vector3;dt=new r({uuid:String,name:String,type:String,vertices:[n],colors:[Number],faces:[t],faceVertexUvs:[[Number]],morphTargets:[Number],morphNormals:[Number],skinWeights:[Number],skinIndices:[Number],lineDistances:[Number],boundingBox:{min:n,max:n},boundingSphere:{center:n,radius:Number},elementsNeedUpdate:Boolean,verticesNeedUpdate:Boolean,uvsNeedUpdate:Boolean,normalsNeedUpdate:Boolean,colorsNeedUpdate:Boolean,lineDistancesNeedUpdate:Boolean,groupsNeedUpdate:Boolean},{collection:"geometries",discriminatorKey:"type"})}(e),dt}function ft(e){lt=e.model("Geometries",mt(e)),lt.discriminator("Geometry",new e.Schema({}))}const ht={getSchemaFrom:mt,getModelFrom:function(e){return lt||ft(e),lt},registerModelTo:function(e){return lt||ft(e),e}};var gt=Object.freeze({__proto__:null,Geometry:ht});
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:pt}=tt;let vt=void 0,yt=void 0;function St(e){return vt||function(e){const t=e.Schema,r=t.Types.Vector2,n=new t({type:{type:String,default:"Curve"},arcLengthDivisions:Number},{id:!1,_id:!1});vt=new t({curves:[n],autoClose:{type:Boolean,default:!1},currentPoint:r})}(e),vt}function Mt(e){const t=pt.getModelFrom(e);yt=t.discriminator("Path",St(e))}var bt={getSchemaFrom:St,getModelFrom:function(e){return yt||Mt(e),yt},registerModelTo:function(e){return yt||Mt(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:Ft}=tt;let _t=void 0,wt=void 0;function Tt(e){return _t||function(e){const t=e.Schema,r=t.Types.Vector2,n=new t({type:{type:String,default:"Curve"},arcLengthDivisions:Number},{id:!1,_id:!1}),o=new t({curves:[n],autoClose:{type:Boolean,default:!1},currentPoint:r},{id:!1,_id:!1});_t=new t({curves:[n],autoClose:{type:Boolean,default:!1},currentPoint:r,uuid:String,holes:[o]})}(e),_t}function Nt(e){const t=Ft.getModelFrom(e);wt=t.discriminator("Shape",Tt(e))}var Bt={getSchemaFrom:Tt,getModelFrom:function(e){return wt||Nt(e),wt},registerModelTo:function(e){return wt||Nt(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:Ot}=tt;let Dt=void 0,Et=void 0;function xt(e){return Dt||function(e){const t=e.Schema;Dt=new t({aX:Number,aY:Number,xRadius:Number,yRadius:Number,aStartAngle:Number,aEndAngle:Number,aClockwise:Boolean,aRotation:Number})}(e),Dt}function It(e){const t=Ot.getModelFrom(e);Et=t.discriminator("ArcCurve",xt(e))}var At={getSchemaFrom:xt,getModelFrom:function(e){return Et||It(e),Et},registerModelTo:function(e){return Et||It(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:Ct}=tt;let jt=void 0,Lt=void 0;function Pt(e){return jt||function(e){const t=e.Schema,r=t.Types.Vector3;jt=new t({points:[r],closed:Boolean,curveType:String,tension:Number})}(e),jt}function Gt(e){const t=Ct.getModelFrom(e);Lt=t.discriminator("CatmullRomCurve3",Pt(e))}var $t={getSchemaFrom:Pt,getModelFrom:function(e){return Lt||Gt(e),Lt},registerModelTo:function(e){return Lt||Gt(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:Vt}=tt;let Rt=void 0,Ut=void 0;function kt(e){return Rt||function(e){const t=e.Schema,r=t.Types.Vector2;Rt=new t({v0:r,v1:r,v2:r,v3:r})}(e),Rt}function zt(e){const t=Vt.getModelFrom(e);Ut=t.discriminator("CubicBezierCurve",kt(e))}var Ht={getSchemaFrom:kt,getModelFrom:function(e){return Ut||zt(e),Ut},registerModelTo:function(e){return Ut||zt(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:qt}=tt;let Wt=void 0,Qt=void 0;function Zt(e){return Wt||function(e){const t=e.Schema,r=t.Types.Vector3;Wt=new t({v0:r,v1:r,v2:r,v3:r})}(e),Wt}function Xt(e){const t=qt.getModelFrom(e);Qt=t.discriminator("CubicBezierCurve3",Zt(e))}var Yt={getSchemaFrom:Zt,getModelFrom:function(e){return Qt||Xt(e),Qt},registerModelTo:function(e){return Qt||Xt(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:Jt}=tt;let Kt=void 0,er=void 0;function tr(e){return Kt||function(e){const t=e.Schema;Kt=new t({})}(e),Kt}function rr(e){const t=Jt.getModelFrom(e);er=t.discriminator("CurveExtras",tr(e))}var nr={getSchemaFrom:tr,getModelFrom:function(e){return er||rr(e),er},registerModelTo:function(e){return er||rr(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:or}=tt;let ir=void 0,ar=void 0;function sr(e){return ir||function(e){const t=e.Schema;ir=new t({aX:Number,aY:Number,xRadius:Number,yRadius:Number,aStartAngle:Number,aEndAngle:Number,aClockwise:Boolean,aRotation:Number})}(e),ir}function cr(e){const t=or.getModelFrom(e);ar=t.discriminator("EllipseCurve",sr(e))}var ur={getSchemaFrom:sr,getModelFrom:function(e){return ar||cr(e),ar},registerModelTo:function(e){return ar||cr(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:dr}=tt;let lr=void 0,mr=void 0;function fr(e){return lr||function(e){const t=e.Schema,r=t.Types.Vector2;lr=new t({v0:r,v1:r})}(e),lr}function hr(e){const t=dr.getModelFrom(e);mr=t.discriminator("LineCurve",fr(e))}var gr={getSchemaFrom:fr,getModelFrom:function(e){return mr||hr(e),mr},registerModelTo:function(e){return mr||hr(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:pr}=tt;let vr=void 0,yr=void 0;function Sr(e){return vr||function(e){const t=e.Schema,r=t.Types.Vector3;vr=new t({v0:r,v1:r})}(e),vr}function Mr(e){const t=pr.getModelFrom(e);yr=t.discriminator("LineCurve3",Sr(e))}var br={getSchemaFrom:Sr,getModelFrom:function(e){return yr||Mr(e),yr},registerModelTo:function(e){return yr||Mr(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:Fr}=tt;let _r=void 0,wr=void 0;function Tr(e){return _r||function(e){const t=e.Schema;_r=new t({})}(e),_r}function Nr(e){const t=Fr.getModelFrom(e);wr=t.discriminator("NURBSCurve",Tr(e))}var Br={getSchemaFrom:Tr,getModelFrom:function(e){return wr||Nr(e),wr},registerModelTo:function(e){return wr||Nr(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:Or}=tt;let Dr=void 0,Er=void 0;function xr(e){return Dr||function(e){const t=e.Schema;Dr=new t({})}(e),Dr}function Ir(e){const t=Or.getModelFrom(e);Er=t.discriminator("NURBSSurface",xr(e))}var Ar={getSchemaFrom:xr,getModelFrom:function(e){return Er||Ir(e),Er},registerModelTo:function(e){return Er||Ir(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:Cr}=tt;let jr=void 0,Lr=void 0;function Pr(e){return jr||function(e){const t=e.Schema,r=t.Types.Vector2;jr=new t({v0:r,v1:r,v2:r})}(e),jr}function Gr(e){const t=Cr.getModelFrom(e);Lr=t.discriminator("QuadraticBezierCurve",Pr(e))}var $r={getSchemaFrom:Pr,getModelFrom:function(e){return Lr||Gr(e),Lr},registerModelTo:function(e){return Lr||Gr(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:Vr}=tt;let Rr=void 0,Ur=void 0;function kr(e){return Rr||function(e){const t=e.Schema,r=t.Types.Vector3;Rr=new t({v0:r,v1:r,v2:r})}(e),Rr}function zr(e){const t=Vr.getModelFrom(e);Ur=t.discriminator("QuadraticBezierCurve3",kr(e))}var Hr={getSchemaFrom:kr,getModelFrom:function(e){return Ur||zr(e),Ur},registerModelTo:function(e){return Ur||zr(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Curve:qr}=tt;let Wr=void 0,Qr=void 0;function Zr(e){return Wr||function(e){const t=e.Schema,r=t.Types.Vector3;Wr=new t({points:[r]})}(e),Wr}function Xr(e){const t=qr.getModelFrom(e);Qr=t.discriminator("SplineCurve",Zr(e))}var Yr={getSchemaFrom:Zr,getModelFrom:function(e){return Qr||Xr(e),Qr},registerModelTo:function(e){return Qr||Xr(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:Jr}=Ze;let Kr=void 0,en=void 0;function tn(e){return Kr||function(e){const t=e.Schema;Kr=new t({})}(e),Kr}function rn(e){const t=Jr.getModelFrom(e);en=t.discriminator("BoxBufferGeometry",tn(e))}var nn={getSchemaFrom:tn,getModelFrom:function(e){return en||rn(e),en},registerModelTo:function(e){return en||rn(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:on}=gt;let an=void 0,sn=void 0;function cn(e){return an||function(e){const t=e.Schema;an=new t({})}(e),an}function un(e){const t=on.getModelFrom(e);sn=t.discriminator("BoxGeometry",cn(e))}var dn={getSchemaFrom:cn,getModelFrom:function(e){return sn||un(e),sn},registerModelTo:function(e){return sn||un(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:ln}=Ze;let mn=void 0,fn=void 0;function hn(e){return mn||function(e){const t=e.Schema;mn=new t({})}(e),mn}function gn(e){const t=ln.getModelFrom(e);fn=t.discriminator("CircleBufferGeometry",hn(e))}var pn={getSchemaFrom:hn,getModelFrom:function(e){return fn||gn(e),fn},registerModelTo:function(e){return fn||gn(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:vn}=gt;let yn=void 0,Sn=void 0;function Mn(e){return yn||function(e){const t=e.Schema;yn=new t({})}(e),yn}function bn(e){const t=vn.getModelFrom(e);Sn=t.discriminator("CircleGeometry",Mn(e))}var Fn={getSchemaFrom:Mn,getModelFrom:function(e){return Sn||bn(e),Sn},registerModelTo:function(e){return Sn||bn(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:_n}=Ze;let wn=void 0,Tn=void 0;function Nn(e){return wn||function(e){const t=e.Schema;wn=new t({})}(e),wn}function Bn(e){const t=_n.getModelFrom(e);Tn=t.discriminator("ConeBufferGeometry",Nn(e))}var On={getSchemaFrom:Nn,getModelFrom:function(e){return Tn||Bn(e),Tn},registerModelTo:function(e){return Tn||Bn(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:Dn}=gt;let En=void 0,xn=void 0;function In(e){return En||function(e){const t=e.Schema;En=new t({})}(e),En}function An(e){const t=Dn.getModelFrom(e);xn=t.discriminator("ConeGeometry",In(e))}var Cn={getSchemaFrom:In,getModelFrom:function(e){return xn||An(e),xn},registerModelTo:function(e){return xn||An(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:jn}=gt;let Ln=void 0,Pn=void 0;function Gn(e){return Ln||function(e){const t=e.Schema;Ln=new t({})}(e),Ln}function $n(e){const t=jn.getModelFrom(e);Pn=t.discriminator("ConvexGeometry",Gn(e))}var Vn={getSchemaFrom:Gn,getModelFrom:function(e){return Pn||$n(e),Pn},registerModelTo:function(e){return Pn||$n(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:Rn}=Ze;let Un=void 0,kn=void 0;function zn(e){return Un||function(e){const t=e.Schema;Un=new t({})}(e),Un}function Hn(e){const t=Rn.getModelFrom(e);kn=t.discriminator("CylinderBufferGeometry",zn(e))}var qn={getSchemaFrom:zn,getModelFrom:function(e){return kn||Hn(e),kn},registerModelTo:function(e){return kn||Hn(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:Wn}=gt;let Qn=void 0,Zn=void 0;function Xn(e){return Qn||function(e){const t=e.Schema;Qn=new t({})}(e),Qn}function Yn(e){const t=Wn.getModelFrom(e);Zn=t.discriminator("CylinderGeometry",Xn(e))}var Jn={getSchemaFrom:Xn,getModelFrom:function(e){return Zn||Yn(e),Zn},registerModelTo:function(e){return Zn||Yn(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:Kn}=gt;let eo=void 0,to=void 0;function ro(e){return eo||function(e){const t=e.Schema;eo=new t({})}(e),eo}function no(e){const t=Kn.getModelFrom(e);to=t.discriminator("DecalGeometry",ro(e))}var oo={getSchemaFrom:ro,getModelFrom:function(e){return to||no(e),to},registerModelTo:function(e){return to||no(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:io}=gt;let ao=void 0,so=void 0;function co(e){return ao||function(e){const t=e.Schema;ao=new t({})}(e),ao}function uo(e){const t=io.getModelFrom(e);so=t.discriminator("DodecahedronGeometry",co(e))}var lo={getSchemaFrom:co,getModelFrom:function(e){return so||uo(e),so},registerModelTo:function(e){return so||uo(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:mo}=gt;let fo=void 0,ho=void 0;function go(e){return fo||function(e){const t=e.Schema;fo=new t({})}(e),fo}function po(e){const t=mo.getModelFrom(e);ho=t.discriminator("EdgesGeometry",go(e))}var vo={getSchemaFrom:go,getModelFrom:function(e){return ho||po(e),ho},registerModelTo:function(e){return ho||po(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:yo}=Ze;let So=void 0,Mo=void 0;function bo(e){return So||function(e){const t=e.Schema;So=new t({})}(e),So}function Fo(e){const t=yo.getModelFrom(e);Mo=t.discriminator("ExtrudeBufferGeometry",bo(e))}var _o={getSchemaFrom:bo,getModelFrom:function(e){return Mo||Fo(e),Mo},registerModelTo:function(e){return Mo||Fo(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:wo}=gt;let To=void 0,No=void 0;function Bo(e){return To||function(e){const t=e.Schema;To=new t({})}(e),To}function Oo(e){const t=wo.getModelFrom(e);No=t.discriminator("ExtrudeGeometry",Bo(e))}var Do={getSchemaFrom:Bo,getModelFrom:function(e){return No||Oo(e),No},registerModelTo:function(e){return No||Oo(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:Eo}=Ze;let xo=void 0,Io=void 0;function Ao(e){return xo||function(e){const t=e.Schema;xo=new t({})}(e),xo}function Co(e){const t=Eo.getModelFrom(e);Io=t.discriminator("IcosahedronBufferGeometry",Ao(e))}var jo={getSchemaFrom:Ao,getModelFrom:function(e){return Io||Co(e),Io},registerModelTo:function(e){return Io||Co(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:Lo}=gt;let Po=void 0,Go=void 0;function $o(e){return Po||function(e){const t=e.Schema;Po=new t({})}(e),Po}function Vo(e){const t=Lo.getModelFrom(e);Go=t.discriminator("IcosahedronGeometry",$o(e))}var Ro={getSchemaFrom:$o,getModelFrom:function(e){return Go||Vo(e),Go},registerModelTo:function(e){return Go||Vo(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:Uo}=Ze;let ko=void 0,zo=void 0;function Ho(e){return ko||function(e){const t=e.Schema;ko=new t({})}(e),ko}function qo(e){const t=Uo.getModelFrom(e);zo=t.discriminator("InstancedBufferGeometry",Ho(e))}var Wo={getSchemaFrom:Ho,getModelFrom:function(e){return zo||qo(e),zo},registerModelTo:function(e){return zo||qo(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:Qo}=Ze;let Zo=void 0,Xo=void 0;function Yo(e){return Zo||function(e){const t=e.Schema;Zo=new t({})}(e),Zo}function Jo(e){const t=Qo.getModelFrom(e);Xo=t.discriminator("LatheBufferGeometry",Yo(e))}var Ko={getSchemaFrom:Yo,getModelFrom:function(e){return Xo||Jo(e),Xo},registerModelTo:function(e){return Xo||Jo(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:ei}=gt;let ti=void 0,ri=void 0;function ni(e){return ti||function(e){const t=e.Schema;ti=new t({})}(e),ti}function oi(e){const t=ei.getModelFrom(e);ri=t.discriminator("LatheGeometry",ni(e))}var ii={getSchemaFrom:ni,getModelFrom:function(e){return ri||oi(e),ri},registerModelTo:function(e){return ri||oi(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:ai}=Ze;let si=void 0,ci=void 0;function ui(e){return si||function(e){const t=e.Schema;si=new t({})}(e),si}function di(e){const t=ai.getModelFrom(e);ci=t.discriminator("OctahedronBufferGeometry",ui(e))}var li={getSchemaFrom:ui,getModelFrom:function(e){return ci||di(e),ci},registerModelTo:function(e){return ci||di(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:mi}=gt;let fi=void 0,hi=void 0;function gi(e){return fi||function(e){const t=e.Schema;fi=new t({})}(e),fi}function pi(e){const t=mi.getModelFrom(e);hi=t.discriminator("OctahedronGeometry",gi(e))}var vi={getSchemaFrom:gi,getModelFrom:function(e){return hi||pi(e),hi},registerModelTo:function(e){return hi||pi(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:yi}=Ze;let Si=void 0,Mi=void 0;function bi(e){return Si||function(e){const t=e.Schema;Si=new t({})}(e),Si}function Fi(e){const t=yi.getModelFrom(e);Mi=t.discriminator("ParametricBufferGeometry",bi(e))}var _i={getSchemaFrom:bi,getModelFrom:function(e){return Mi||Fi(e),Mi},registerModelTo:function(e){return Mi||Fi(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:wi}=gt;let Ti=void 0,Ni=void 0;function Bi(e){return Ti||function(e){const t=e.Schema;Ti=new t({})}(e),Ti}function Oi(e){const t=wi.getModelFrom(e);Ni=t.discriminator("ParametricGeometry",Bi(e))}var Di={getSchemaFrom:Bi,getModelFrom:function(e){return Ni||Oi(e),Ni},registerModelTo:function(e){return Ni||Oi(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:Ei}=Ze;let xi=void 0,Ii=void 0;function Ai(e){return xi||function(e){const t=e.Schema;xi=new t({})}(e),xi}function Ci(e){const t=Ei.getModelFrom(e);Ii=t.discriminator("PlaneBufferGeometry",Ai(e))}var ji={getSchemaFrom:Ai,getModelFrom:function(e){return Ii||Ci(e),Ii},registerModelTo:function(e){return Ii||Ci(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:Li}=gt;let Pi=void 0,Gi=void 0;function $i(e){return Pi||function(e){const t=e.Schema;Pi=new t({})}(e),Pi}function Vi(e){const t=Li.getModelFrom(e);Gi=t.discriminator("PlaneGeometry",$i(e))}var Ri={getSchemaFrom:$i,getModelFrom:function(e){return Gi||Vi(e),Gi},registerModelTo:function(e){return Gi||Vi(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:Ui}=Ze;let ki=void 0,zi=void 0;function Hi(e){return ki||function(e){const t=e.Schema;ki=new t({})}(e),ki}function qi(e){const t=Ui.getModelFrom(e);zi=t.discriminator("PolyhedronBufferGeometry",Hi(e))}var Wi={getSchemaFrom:Hi,getModelFrom:function(e){return zi||qi(e),zi},registerModelTo:function(e){return zi||qi(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:Qi}=gt;let Zi=void 0,Xi=void 0;function Yi(e){return Zi||function(e){const t=e.Schema;Zi=new t({})}(e),Zi}function Ji(e){const t=Qi.getModelFrom(e);Xi=t.discriminator("PolyhedronGeometry",Yi(e))}var Ki={getSchemaFrom:Yi,getModelFrom:function(e){return Xi||Ji(e),Xi},registerModelTo:function(e){return Xi||Ji(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:ea}=Ze;let ta=void 0,ra=void 0;function na(e){return ta||function(e){const t=e.Schema;ta=new t({})}(e),ta}function oa(e){const t=ea.getModelFrom(e);ra=t.discriminator("RingBufferGeometry",na(e))}var ia={getSchemaFrom:na,getModelFrom:function(e){return ra||oa(e),ra},registerModelTo:function(e){return ra||oa(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:aa}=gt;let sa=void 0,ca=void 0;function ua(e){return sa||function(e){const t=e.Schema;sa=new t({})}(e),sa}function da(e){const t=aa.getModelFrom(e);ca=t.discriminator("RingGeometry",ua(e))}var la={getSchemaFrom:ua,getModelFrom:function(e){return ca||da(e),ca},registerModelTo:function(e){return ca||da(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:ma}=Ze;let fa=void 0,ha=void 0;function ga(e){return fa||function(e){const t=e.Schema,r=t.Types.Vector2,n=new t({type:{type:String,default:"Curve"},arcLengthDivisions:Number},{id:!1,_id:!1}),o=new t({curves:[n],autoClose:{type:Boolean,default:!1},currentPoint:r},{id:!1,_id:!1}),i=new t({curves:[n],autoClose:{type:Boolean,default:!1},currentPoint:r,uuid:String,holes:[o]},{id:!1,_id:!1});fa=new t({shapes:[i],curveSegments:Number})}(e),fa}function pa(e){const t=ma.getModelFrom(e);ha=t.discriminator("ShapeBufferGeometry",ga(e))}var va={getSchemaFrom:ga,getModelFrom:function(e){return ha||pa(e),ha},registerModelTo:function(e){return ha||pa(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:ya}=gt;let Sa=void 0,Ma=void 0;function ba(e){return Sa||function(e){const t=e.Schema;Sa=new t({})}(e),Sa}function Fa(e){const t=ya.getModelFrom(e);Ma=t.discriminator("ShapeGeometry",ba(e))}var _a={getSchemaFrom:ba,getModelFrom:function(e){return Ma||Fa(e),Ma},registerModelTo:function(e){return Ma||Fa(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:wa}=Ze;let Ta=void 0,Na=void 0;function Ba(e){return Ta||function(e){const t=e.Schema;Ta=new t({})}(e),Ta}function Oa(e){const t=wa.getModelFrom(e);Na=t.discriminator("SphereBufferGeometry",Ba(e))}var Da={getSchemaFrom:Ba,getModelFrom:function(e){return Na||Oa(e),Na},registerModelTo:function(e){return Na||Oa(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:Ea}=gt;let xa=void 0,Ia=void 0;function Aa(e){return xa||function(e){const t=e.Schema;xa=new t({})}(e),xa}function Ca(e){const t=Ea.getModelFrom(e);Ia=t.discriminator("SphereGeometry",Aa(e))}var ja={getSchemaFrom:Aa,getModelFrom:function(e){return Ia||Ca(e),Ia},registerModelTo:function(e){return Ia||Ca(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:La}=Ze;let Pa=void 0,Ga=void 0;function $a(e){return Pa||function(e){const t=e.Schema;Pa=new t({})}(e),Pa}function Va(e){const t=La.getModelFrom(e);Ga=t.discriminator("TeapotBufferGeometry",$a(e))}var Ra={getSchemaFrom:$a,getModelFrom:function(e){return Ga||Va(e),Ga},registerModelTo:function(e){return Ga||Va(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:Ua}=Ze;let ka=void 0,za=void 0;function Ha(e){return ka||function(e){const t=e.Schema;ka=new t({})}(e),ka}function qa(e){const t=Ua.getModelFrom(e);za=t.discriminator("TetrahedronBufferGeometry",Ha(e))}var Wa={getSchemaFrom:Ha,getModelFrom:function(e){return za||qa(e),za},registerModelTo:function(e){return za||qa(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:Qa}=gt;let Za=void 0,Xa=void 0;function Ya(e){return Za||function(e){const t=e.Schema;Za=new t({})}(e),Za}function Ja(e){const t=Qa.getModelFrom(e);Xa=t.discriminator("TetrahedronGeometry",Ya(e))}var Ka={getSchemaFrom:Ya,getModelFrom:function(e){return Xa||Ja(e),Xa},registerModelTo:function(e){return Xa||Ja(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:es}=Ze;let ts=void 0,rs=void 0;function ns(e){return ts||function(e){const t=e.Schema;ts=new t({})}(e),ts}function os(e){const t=es.getModelFrom(e);rs=t.discriminator("TextBufferGeometry",ns(e))}var is={getSchemaFrom:ns,getModelFrom:function(e){return rs||os(e),rs},registerModelTo:function(e){return rs||os(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:as}=gt;let ss=void 0,cs=void 0;function us(e){return ss||function(e){const t=e.Schema;ss=new t({})}(e),ss}function ds(e){const t=as.getModelFrom(e);cs=t.discriminator("TextGeometry",us(e))}var ls={getSchemaFrom:us,getModelFrom:function(e){return cs||ds(e),cs},registerModelTo:function(e){return cs||ds(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:ms}=Ze;let fs=void 0,hs=void 0;function gs(e){return fs||function(e){const t=e.Schema;fs=new t({})}(e),fs}function ps(e){const t=ms.getModelFrom(e);hs=t.discriminator("TorusBufferGeometry",gs(e))}var vs={getSchemaFrom:gs,getModelFrom:function(e){return hs||ps(e),hs},registerModelTo:function(e){return hs||ps(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:ys}=gt;let Ss=void 0,Ms=void 0;function bs(e){return Ss||function(e){const t=e.Schema;Ss=new t({})}(e),Ss}function Fs(e){const t=ys.getModelFrom(e);Ms=t.discriminator("TorusGeometry",bs(e))}var _s={getSchemaFrom:bs,getModelFrom:function(e){return Ms||Fs(e),Ms},registerModelTo:function(e){return Ms||Fs(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:ws}=Ze;let Ts=void 0,Ns=void 0;function Bs(e){return Ts||function(e){const t=e.Schema;Ts=new t({})}(e),Ts}function Os(e){const t=ws.getModelFrom(e);Ns=t.discriminator("TorusKnotBufferGeometry",Bs(e))}var Ds={getSchemaFrom:Bs,getModelFrom:function(e){return Ns||Os(e),Ns},registerModelTo:function(e){return Ns||Os(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:Es}=gt;let xs=void 0,Is=void 0;function As(e){return xs||function(e){const t=e.Schema;xs=new t({})}(e),xs}function Cs(e){const t=Es.getModelFrom(e);Is=t.discriminator("TorusKnotGeometry",As(e))}var js={getSchemaFrom:As,getModelFrom:function(e){return Is||Cs(e),Is},registerModelTo:function(e){return Is||Cs(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{BufferGeometry:Ls}=Ze;let Ps=void 0,Gs=void 0;function $s(e){return Ps||function(e){const t=e.Schema;Ps=new t({})}(e),Ps}function Vs(e){const t=Ls.getModelFrom(e);Gs=t.discriminator("TubeBufferGeometry",$s(e))}var Rs={getSchemaFrom:$s,getModelFrom:function(e){return Gs||Vs(e),Gs},registerModelTo:function(e){return Gs||Vs(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:Us}=gt;let ks=void 0,zs=void 0;function Hs(e){return ks||function(e){const t=e.Schema;ks=new t({})}(e),ks}function qs(e){const t=Us.getModelFrom(e);zs=t.discriminator("TubeGeometry",Hs(e))}var Ws={getSchemaFrom:Hs,getModelFrom:function(e){return zs||qs(e),zs},registerModelTo:function(e){return zs||qs(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Geometry:Qs}=gt;let Zs=void 0,Xs=void 0;function Ys(e){return Zs||function(e){const t=e.Schema;Zs=new t({})}(e),Zs}function Js(e){const t=Qs.getModelFrom(e);Xs=t.discriminator("WireframeGeometry",Ys(e))}var Ks={getSchemaFrom:Ys,getModelFrom:function(e){return Xs||Js(e),Xs},registerModelTo:function(e){return Xs||Js(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:ec}=C;let tc=void 0,rc=void 0;function nc(e){return tc||function(e){const t=e.Schema;tc=new t({})}(e),tc}function oc(e){const t=ec.getModelFrom(e);rc=t.discriminator("ArrowHelper",nc(e))}var ic={getSchemaFrom:nc,getModelFrom:function(e){return rc||oc(e),rc},registerModelTo:function(e){return rc||oc(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:ac}=C;let sc=void 0,cc=void 0;function uc(e){return sc||function(e){const t=e.Schema;sc=new t({})}(e),sc}function dc(e){const t=ac.getModelFrom(e);cc=t.discriminator("AxesHelper",uc(e))}var lc={getSchemaFrom:uc,getModelFrom:function(e){return cc||dc(e),cc},registerModelTo:function(e){return cc||dc(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:mc}=C;let fc=void 0,hc=void 0;function gc(e){return fc||function(e){const t=e.Schema;fc=new t({})}(e),fc}function pc(e){const t=mc.getModelFrom(e);hc=t.discriminator("Box3Helper",gc(e))}var vc={getSchemaFrom:gc,getModelFrom:function(e){return hc||pc(e),hc},registerModelTo:function(e){return hc||pc(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:yc}=C;let Sc=void 0,Mc=void 0;function bc(e){return Sc||function(e){const t=e.Schema;Sc=new t({})}(e),Sc}function Fc(e){const t=yc.getModelFrom(e);Mc=t.discriminator("BoxHelper",bc(e))}var _c={getSchemaFrom:bc,getModelFrom:function(e){return Mc||Fc(e),Mc},registerModelTo:function(e){return Mc||Fc(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:wc}=C;let Tc=void 0,Nc=void 0;function Bc(e){return Tc||function(e){const t=e.Schema;Tc=new t({})}(e),Tc}function Oc(e){const t=wc.getModelFrom(e);Nc=t.discriminator("CameraHelper",Bc(e))}var Dc={getSchemaFrom:Bc,getModelFrom:function(e){return Nc||Oc(e),Nc},registerModelTo:function(e){return Nc||Oc(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Ec}=C;let xc=void 0,Ic=void 0;function Ac(e){return xc||function(e){const t=e.Schema;xc=new t({})}(e),xc}function Cc(e){const t=Ec.getModelFrom(e);Ic=t.discriminator("DirectionalLightHelper",Ac(e))}var jc={getSchemaFrom:Ac,getModelFrom:function(e){return Ic||Cc(e),Ic},registerModelTo:function(e){return Ic||Cc(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Lc}=C;let Pc=void 0,Gc=void 0;function $c(e){return Pc||function(e){const t=e.Schema;Pc=new t({})}(e),Pc}function Vc(e){const t=Lc.getModelFrom(e);Gc=t.discriminator("FaceNormalsHelper",$c(e))}var Rc={getSchemaFrom:$c,getModelFrom:function(e){return Gc||Vc(e),Gc},registerModelTo:function(e){return Gc||Vc(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Uc}=C;let kc=void 0,zc=void 0;function Hc(e){return kc||function(e){const t=e.Schema;kc=new t({})}(e),kc}function qc(e){const t=Uc.getModelFrom(e);zc=t.discriminator("GridHelper",Hc(e))}var Wc={getSchemaFrom:Hc,getModelFrom:function(e){return zc||qc(e),zc},registerModelTo:function(e){return zc||qc(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Qc}=C;let Zc=void 0,Xc=void 0;function Yc(e){return Zc||function(e){const t=e.Schema;Zc=new t({})}(e),Zc}function Jc(e){const t=Qc.getModelFrom(e);Xc=t.discriminator("HemisphereLightHelper",Yc(e))}var Kc={getSchemaFrom:Yc,getModelFrom:function(e){return Xc||Jc(e),Xc},registerModelTo:function(e){return Xc||Jc(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:eu}=C;let tu=void 0,ru=void 0;function nu(e){return tu||function(e){const t=e.Schema;tu=new t({})}(e),tu}function ou(e){const t=eu.getModelFrom(e);ru=t.discriminator("PlaneHelper",nu(e))}var iu={getSchemaFrom:nu,getModelFrom:function(e){return ru||ou(e),ru},registerModelTo:function(e){return ru||ou(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:au}=C;let su=void 0,cu=void 0;function uu(e){return su||function(e){const t=e.Schema;su=new t({})}(e),su}function du(e){const t=au.getModelFrom(e);cu=t.discriminator("PointLightHelper",uu(e))}var lu={getSchemaFrom:uu,getModelFrom:function(e){return cu||du(e),cu},registerModelTo:function(e){return cu||du(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:mu}=C;let fu=void 0,hu=void 0;function gu(e){return fu||function(e){const t=e.Schema;fu=new t({})}(e),fu}function pu(e){const t=mu.getModelFrom(e);hu=t.discriminator("PolarGridHelper",gu(e))}var vu={getSchemaFrom:gu,getModelFrom:function(e){return hu||pu(e),hu},registerModelTo:function(e){return hu||pu(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:yu}=C;let Su=void 0,Mu=void 0;function bu(e){return Su||function(e){const t=e.Schema;Su=new t({})}(e),Su}function Fu(e){const t=yu.getModelFrom(e);Mu=t.discriminator("RectAreaLightHelper",bu(e))}var _u={getSchemaFrom:bu,getModelFrom:function(e){return Mu||Fu(e),Mu},registerModelTo:function(e){return Mu||Fu(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:wu}=C;let Tu=void 0,Nu=void 0;function Bu(e){return Tu||function(e){const t=e.Schema;Tu=new t({})}(e),Tu}function Ou(e){const t=wu.getModelFrom(e);Nu=t.discriminator("SkeletonHelper",Bu(e))}var Du={getSchemaFrom:Bu,getModelFrom:function(e){return Nu||Ou(e),Nu},registerModelTo:function(e){return Nu||Ou(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Eu}=C;let xu=void 0,Iu=void 0;function Au(e){return xu||function(e){const t=e.Schema;xu=new t({})}(e),xu}function Cu(e){const t=Eu.getModelFrom(e);Iu=t.discriminator("SpotLightHelper",Au(e))}var ju={getSchemaFrom:Au,getModelFrom:function(e){return Iu||Cu(e),Iu},registerModelTo:function(e){return Iu||Cu(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Lu}=C;let Pu=void 0,Gu=void 0;function $u(e){return Pu||function(e){const t=e.Schema;Pu=new t({})}(e),Pu}function Vu(e){const t=Lu.getModelFrom(e);Gu=t.discriminator("VertexNormalsHelper",$u(e))}var Ru={getSchemaFrom:$u,getModelFrom:function(e){return Gu||Vu(e),Gu},registerModelTo:function(e){return Gu||Vu(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Uu}=C;let ku=void 0,zu=void 0;function Hu(e){return ku||function(e){const t=e.Schema;ku=new t({})}(e),ku}function qu(e){const t=Uu.getModelFrom(e);zu=t.discriminator("AmbientLight",Hu(e))}var Wu={getSchemaFrom:Hu,getModelFrom:function(e){return zu||qu(e),zu},registerModelTo:function(e){return zu||qu(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Qu}=C;let Zu=void 0,Xu=void 0;function Yu(e){return Zu||function(e){const t=e.Schema;Zu=new t({})}(e),Zu}function Ju(e){const t=Qu.getModelFrom(e);Xu=t.discriminator("DirectionalLight",Yu(e))}var Ku={getSchemaFrom:Yu,getModelFrom:function(e){return Xu||Ju(e),Xu},registerModelTo:function(e){return Xu||Ju(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:ed}=C;let td=void 0,rd=void 0;function nd(e){return td||function(e){const t=e.Schema;td=new t({})}(e),td}function od(e){const t=ed.getModelFrom(e);rd=t.discriminator("HemisphereLight",nd(e))}var id={getSchemaFrom:nd,getModelFrom:function(e){return rd||od(e),rd},registerModelTo:function(e){return rd||od(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:ad}=C;let sd=void 0,cd=void 0;function ud(e){return sd||function(e){const t=e.Schema;sd=new t({})}(e),sd}function dd(e){const t=ad.getModelFrom(e);cd=t.discriminator("Light",ud(e))}var ld={getSchemaFrom:ud,getModelFrom:function(e){return cd||dd(e),cd},registerModelTo:function(e){return cd||dd(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:md}=C;let fd=void 0,hd=void 0;function gd(e){return fd||function(e){const t=e.Schema;fd=new t({})}(e),fd}function pd(e){const t=md.getModelFrom(e);hd=t.discriminator("PointLight",gd(e))}var vd={getSchemaFrom:gd,getModelFrom:function(e){return hd||pd(e),hd},registerModelTo:function(e){return hd||pd(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:yd}=C;let Sd=void 0,Md=void 0;function bd(e){return Sd||function(e){const t=e.Schema;Sd=new t({})}(e),Sd}function Fd(e){const t=yd.getModelFrom(e);Md=t.discriminator("RectAreaLight",bd(e))}var _d={getSchemaFrom:bd,getModelFrom:function(e){return Md||Fd(e),Md},registerModelTo:function(e){return Md||Fd(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:wd}=C;let Td=void 0,Nd=void 0;function Bd(e){return Td||function(e){const t=e.Schema;Td=new t({})}(e),Td}function Od(e){const t=wd.getModelFrom(e);Nd=t.discriminator("SpotLight",Bd(e))}var Dd={getSchemaFrom:Bd,getModelFrom:function(e){return Nd||Od(e),Nd},registerModelTo:function(e){return Nd||Od(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Material
 *
 * @description Todo...
 */let Ed=void 0,xd=void 0;function Id(e){return Ed||function(e){const t=e.Schema,r=t.Types.Mixed;Ed=new t({uuid:String,name:String,type:String,fog:Boolean,lights:Boolean,blending:Number,side:Number,flatShading:Boolean,vertexColors:Number,opacity:Number,transparent:Boolean,blendSrc:Number,blendDst:Number,blendEquation:Number,blendSrcAlpha:String,blendDstAlpha:String,blendEquationAlpha:String,depthFunc:Number,depthTest:Boolean,depthWrite:Boolean,clippingPlanes:r,clipIntersection:Boolean,clipShadows:Boolean,colorWrite:Boolean,precision:Number,polygonOffset:Boolean,polygonOffsetFactor:Number,polygonOffsetUnits:Number,dithering:Boolean,alphaTest:Number,premultipliedAlpha:Boolean,overdraw:Number,visible:Boolean,userData:r,needsUpdate:Boolean},{collection:"materials",discriminatorKey:"type"})}(e),Ed}function Ad(e){xd=e.model("Materials",Id(e)),xd.discriminator("Material",new e.Schema({}))}var Cd={getSchemaFrom:Id,getModelFrom:function(e){return xd||Ad(e),xd},registerModelTo:function(e){return xd||Ad(e),e}},jd={Material:Cd};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
const{Material:Ld}=jd;let Pd=void 0,Gd=void 0;function $d(e){return Pd||function(e){const t=e.Schema,r=t.Types.Color;Pd=new t({color:r,light:Boolean,lineWidth:Number,linecap:String,linejoin:String})}(e),Pd}function Vd(e){const t=Ld.getModelFrom(e);Gd=t.discriminator("LineBasicMaterial",$d(e))}var Rd={getSchemaFrom:$d,getModelFrom:function(e){return Gd||Vd(e),Gd},registerModelTo:function(e){return Gd||Vd(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:Ud}=jd;let kd=void 0,zd=void 0;function Hd(e){return kd||function(e){const t=e.Schema,r=t.Types.Color;kd=new t({color:r,light:Boolean,lineWidth:Number,linecap:String,linejoin:String,dashSize:Number,gapSize:Number,scale:Number})}(e),kd}function qd(e){const t=Ud.getModelFrom(e);zd=t.discriminator("LineDashedMaterial",Hd(e))}var Wd={getSchemaFrom:Hd,getModelFrom:function(e){return zd||qd(e),zd},registerModelTo:function(e){return zd||qd(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:Qd}=jd;let Zd=void 0,Xd=void 0;function Yd(e){return Zd||function(e){const t=e.Schema,r=t.Types,n=r.Mixed,o=r.Color;Zd=new t({color:o,map:n,lightMap:n,lightMapIntensity:Number,aoMap:n,aoMapIntensity:Number,specularMap:n,alphaMap:n,envMap:n,combine:Number,reflectivity:Number,refractionRatio:Number,wireframe:Boolean,wireframeLinewidth:Number,wireframeLinecap:String,wireframeLinejoin:String,skinning:Boolean,morphTargets:Boolean,light:Boolean})}(e),Zd}function Jd(e){const t=Qd.getModelFrom(e);Xd=t.discriminator("MeshBasicMaterial",Yd(e))}var Kd={getSchemaFrom:Yd,getModelFrom:function(e){return Xd||Jd(e),Xd},registerModelTo:function(e){return Xd||Jd(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:el}=jd;let tl=void 0,rl=void 0;function nl(e){return tl||function(e){const t=e.Schema,r=t.Types.Mixed;tl=new t({depthPacking:Number,skinning:Boolean,morphTargets:Boolean,map:r,alphaMap:r,displacementMap:r,displacementScale:Number,displacementBias:Number,wireframe:Boolean,wireframeLinewidth:Number,fog:Boolean,light:Boolean})}(e),tl}function ol(e){const t=el.getModelFrom(e);rl=t.discriminator("MeshDepthMaterial",nl(e))}var il={getSchemaFrom:nl,getModelFrom:function(e){return rl||ol(e),rl},registerModelTo:function(e){return rl||ol(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:al}=jd;let sl=void 0,cl=void 0;function ul(e){return sl||function(e){const t=e.Schema,r=t.Types,n=r.Color,o=r.Mixed;sl=new t({color:n,map:o,lightMap:o,lightMapIntensity:Number,aoMap:o,aoMapIntensity:Number,emissive:n,emissiveIntensity:Number,emissiveMap:o,specularMap:o,alphaMap:o,envMap:o,combine:Number,reflectivity:Number,refractionRatio:Number,wireframe:Boolean,wireframeLinewidth:Number,wireframeLinecap:String,wireframeLinejoin:String,skinning:Boolean,morphTargets:Boolean,morphNormals:Boolean})}(e),sl}function dl(e){const t=al.getModelFrom(e);cl=t.discriminator("MeshLambertMaterial",ul(e))}var ll={getSchemaFrom:ul,getModelFrom:function(e){return cl||dl(e),cl},registerModelTo:function(e){return cl||dl(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:ml}=jd;let fl=void 0,hl=void 0;function gl(e){return fl||function(e){const t=e.Schema,r=t.Types,n=r.Mixed,o=r.Vector2;fl=new t({bumpMap:n,bumpScale:Number,normalMap:n,normalScale:o,displacementMap:n,displacementScale:Number,displacementBias:Number,wireframe:Boolean,wireframeLinewidth:Number,fog:Boolean,light:Boolean,skinning:Boolean,morphTargets:Boolean,morphNormals:Boolean})}(e),fl}function pl(e){const t=ml.getModelFrom(e);hl=t.discriminator("MeshNormalMaterial",gl(e))}var vl={getSchemaFrom:gl,getModelFrom:function(e){return hl||pl(e),hl},registerModelTo:function(e){return hl||pl(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:yl}=jd;let Sl=void 0,Ml=void 0;function bl(e){return Sl||function(e){const t=e.Schema,r=t.Types,n=r.Mixed,o=r.Color,i=r.Vector2;Sl=new t({color:o,specular:o,shininess:Number,map:n,lightMap:n,lightMapIntensity:Number,aoMap:n,aoMapIntensity:Number,emissive:o,emissiveIntensity:Number,emissiveMap:n,bumpMap:n,bumpScale:Number,normalMap:n,normalScale:i,displacementMap:n,displacementScale:Number,displacementBias:Number,specularMap:n,alphaMap:n,envMap:n,combine:Number,reflectivity:Number,refractionRatio:Number,wireframe:Boolean,wireframeLinewidth:Number,wireframeLinecap:String,wireframeLinejoin:String,skinning:Boolean,morphTargets:Boolean,morphNormals:Boolean})}(e),Sl}function Fl(e){const t=yl.getModelFrom(e);Ml=t.discriminator("MeshPhongMaterial",bl(e))}var _l={getSchemaFrom:bl,getModelFrom:function(e){return Ml||Fl(e),Ml},registerModelTo:function(e){return Ml||Fl(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:wl}=jd;let Tl=void 0,Nl=void 0;function Bl(e){return Tl||function(e){const t=e.Schema;Tl=new t({reflectivity:Number,clearCoat:Number,clearCoatRoughness:Number})}(e),Tl}function Ol(e){const t=wl.getModelFrom(e);Nl=t.discriminator("MeshPhysicalMaterial",Bl(e))}var Dl={getSchemaFrom:Bl,getModelFrom:function(e){return Nl||Ol(e),Nl},registerModelTo:function(e){return Nl||Ol(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:El}=jd;let xl=void 0,Il=void 0;function Al(e){return xl||function(e){const t=e.Schema,r=t.Types,n=r.Mixed,o=r.Color,i=r.Vector2;xl=new t({color:o,roughness:Number,metalness:Number,map:n,lightMap:n,lightMapIntensity:Number,aoMap:n,aoMapIntensity:Number,emissive:o,emissiveIntensity:Number,emissiveMap:n,bumpMap:n,bumpScale:Number,normalMap:n,normalScale:i,displacementMap:n,displacementScale:Number,displacementBias:Number,roughnessMap:n,metalnessMap:n,alphaMap:n,envMap:n,envMapIntensity:Number,refractionRatio:Number,wireframe:Boolean,wireframeLinewidth:Number,wireframeLinecap:String,wireframeLinejoin:String,skinning:Boolean,morphTargets:Boolean,morphNormals:Boolean})}(e),xl}function Cl(e){const t=El.getModelFrom(e);Il=t.discriminator("MeshStandardMaterial",Al(e))}var jl={getSchemaFrom:Al,getModelFrom:function(e){return Il||Cl(e),Il},registerModelTo:function(e){return Il||Cl(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:Ll}=jd;let Pl=void 0,Gl=void 0;function $l(e){return Pl||function(e){const t=e.Schema,r=t.Types,n=r.Mixed,o=r.Color,i=r.Vector2;Pl=new t({color:o,specular:o,shininess:Number,map:n,lightMap:n,lightMapIntensity:Number,aoMap:n,aoMapIntensity:Number,emissive:o,emissiveIntensity:Number,emissiveMap:n,bumpMap:n,bumpScale:Number,normalMap:n,normalScale:i,displacementMap:n,displacementScale:Number,displacementBias:Number,specularMap:n,alphaMap:n,envMap:n,combine:Number,reflectivity:Number,refractionRatio:Number,wireframe:Boolean,wireframeLinewidth:Number,wireframeLinecap:String,wireframeLinejoin:String,skinning:Boolean,morphTargets:Boolean,morphNormals:Boolean,gradientMap:n})}(e),Pl}function Vl(e){const t=Ll.getModelFrom(e);Gl=t.discriminator("MeshToonMaterial",$l(e))}var Rl={getSchemaFrom:$l,getModelFrom:function(e){return Gl||Vl(e),Gl},registerModelTo:function(e){return Gl||Vl(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:Ul}=jd;let kl=void 0,zl=void 0;function Hl(e){return kl||function(e){const t=e.Schema,r=t.Types,n=r.Color,o=r.Mixed;kl=new t({color:n,map:o,size:Number,sizeAttenuation:Boolean,lights:Boolean})}(e),kl}function ql(e){const t=Ul.getModelFrom(e);zl=t.discriminator("PointsMaterial",Hl(e))}var Wl={getSchemaFrom:Hl,getModelFrom:function(e){return zl||ql(e),zl},registerModelTo:function(e){return zl||ql(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:Ql}=jd;let Zl=void 0,Xl=void 0;function Yl(e){return Zl||function(e){const t=e.Schema,r=t.Types.Mixed;Zl=new t({defines:r,uniforms:r,vertexShader:String,fragmentShader:String,linewidth:Number,wireframe:Boolean,wireframeLinewidth:Number,fog:Boolean,light:Boolean,clipping:Boolean,skinning:Boolean,morphTargets:Boolean,morphNormals:Boolean,derivatives:Boolean,fragDepth:Boolean,drawBuffers:Boolean,shaderTextureLOD:Boolean})}(e),Zl}function Jl(e){const t=Ql.getModelFrom(e);Xl=t.discriminator("RawShaderMaterial",Yl(e))}var Kl={getSchemaFrom:Yl,getModelFrom:function(e){return Xl||Jl(e),Xl},registerModelTo:function(e){return Xl||Jl(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:em}=jd;let tm=void 0,rm=void 0;function nm(e){return tm||function(e){const t=e.Schema,r=t.Types.Mixed;tm=new t({defines:r,uniforms:r,vertexShader:String,fragmentShader:String,linewidth:Number,wireframe:Boolean,wireframeLinewidth:Number,fog:Boolean,light:Boolean,clipping:Boolean,skinning:Boolean,morphTargets:Boolean,morphNormals:Boolean,derivatives:Boolean,fragDepth:Boolean,drawBuffers:Boolean,shaderTextureLOD:Boolean})}(e),tm}function om(e){const t=em.getModelFrom(e);rm=t.discriminator("ShaderMaterial",nm(e))}var im={getSchemaFrom:nm,getModelFrom:function(e){return rm||om(e),rm},registerModelTo:function(e){return rm||om(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:am}=jd;let sm=void 0,cm=void 0;function um(e){return sm||function(e){const t=e.Schema,r=t.Types.Color;sm=new t({color:r,opacity:Number,lights:Boolean,transparent:Boolean})}(e),sm}function dm(e){const t=am.getModelFrom(e);cm=t.discriminator("ShadowMaterial",um(e))}var lm={getSchemaFrom:um,getModelFrom:function(e){return cm||dm(e),cm},registerModelTo:function(e){return cm||dm(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Material:mm}=jd;let fm=void 0,hm=void 0;function gm(e){return fm||function(e){const t=e.Schema,r=t.Types,n=r.Color,o=r.Mixed;fm=new t({color:n,map:o,rotation:Number,fog:Boolean,lights:Boolean})}(e),fm}function pm(e){const t=mm.getModelFrom(e);hm=t.discriminator("SpriteMaterial",gm(e))}var vm={getSchemaFrom:gm,getModelFrom:function(e){return hm||pm(e),hm},registerModelTo:function(e){return hm||pm(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Core/Box2
 *
 * @description The database counterpart of Three.Box2
 */let ym=void 0;var Sm={getSchemaFrom:function(e){return ym||function(e){const t=e.Schema,r=t.Types.Vector2;ym=new t({min:r,max:r},{_id:!1,id:!1})}(e),ym},getModelFrom:()=>null,registerModelTo:e=>e};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */let Mm=void 0;var bm={getSchemaFrom:function(e){return Mm||function(e){const t=e.Schema,r=t.Types.Vector3;Mm=new t({min:r,max:r},{_id:!1,id:!1})}(e),Mm},getModelFrom:()=>null,registerModelTo:e=>e};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Face3
 *
 * @description Todo...
 */let Fm=void 0;var _m={getSchemaFrom:function(e){return Fm||function(e){const t=e.Schema,r=t.Types.Vector3;Fm=new t({start:r,end:r},{_id:!1,id:!1})}(e),Fm},getModelFrom:()=>null,registerModelTo:e=>e};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Core/Vector3
 *
 * @description The database counterpart of Three.Vector3
 */let wm=void 0;var Tm={getSchemaFrom:function(e){return wm||function(e){const t=e.Schema,r=t.Types.Vector3;wm=new t({normal:r,constant:Number},{_id:!1,id:!1})}(e),wm},getModelFrom:()=>null,registerModelTo:e=>e};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Core/Vector3
 *
 * @description The database counterpart of Three.Vector3
 */let Nm=void 0;var Bm={getSchemaFrom:function(e){return Nm||function(e){const t=e.Schema,r=t.Types.Vector3;Nm=new t({origin:r,direction:r},{_id:!1,id:!1})}(e),Nm},getModelFrom:()=>null,registerModelTo:e=>e};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Core/Vector3
 *
 * @description The database counterpart of Three.Vector3
 */let Om=void 0;var Dm={getSchemaFrom:function(e){return Om||function(e){const t=e.Schema,r=t.Types.Vector3;Om=new t({center:r,radius:Number},{_id:!1,id:!1})}(e),Om},getModelFrom:()=>null,registerModelTo:e=>e};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Core/Vector3
 *
 * @description The database counterpart of Three.Vector3
 */let Em=void 0;var xm={getSchemaFrom:function(e){return Em||function(e){const t=e.Schema;Em=new t({radius:Number,phi:Number,theta:Number},{_id:!1,id:!1})}(e),Em},getModelFrom:()=>null,registerModelTo:e=>e};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Core/Vector3
 *
 * @description The database counterpart of Three.Vector3
 */let Im=void 0;var Am={getSchemaFrom:function(e){return Im||function(e){const t=e.Schema,r=t.Types.Vector3;Im=new t({a:r,b:r,c:r},{_id:!1,id:!1})}(e),Im},getModelFrom:()=>null,registerModelTo:e=>e};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Cm}=C;let jm=void 0,Lm=void 0;function Pm(e){return jm||function(e){const t=e.Schema;jm=new t({})}(e),jm}function Gm(e){const t=Cm.getModelFrom(e);Lm=t.discriminator("Bone",Pm(e))}var $m={getSchemaFrom:Pm,getModelFrom:function(e){return Lm||Gm(e),Lm},registerModelTo:function(e){return Lm||Gm(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */let Vm=void 0,Rm=void 0;function Um(e){return Vm||function(e){const t=e.Schema;Vm=new t({})}(e),Vm}function km(e){const t=A.getModelFrom(e);Rm=t.discriminator("Group",Um(e))}const zm={getSchemaFrom:Um,getModelFrom:function(e){return Rm||km(e),Rm},registerModelTo:function(e){return Rm||km(e),e}},{Object3D:Hm}=C;
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */let qm=void 0,Wm=void 0;function Qm(e){return qm||function(e){const t=e.Schema;qm=new t({})}(e),qm}function Zm(e){const t=Hm.getModelFrom(e);Wm=t.discriminator("ImmediateRenderObject",Qm(e))}var Xm={getSchemaFrom:Qm,getModelFrom:function(e){return Wm||Zm(e),Wm},registerModelTo:function(e){return Wm||Zm(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Ym}=C;let Jm=void 0,Km=void 0;function ef(e){return Jm||function(e){const t=e.Schema,r=t.Types,n=r.ObjectId,o=r.Color,i=r.Vector3;Jm=new t({lensFlares:[{texture:n,size:Number,distance:Number,x:Number,y:Number,z:Number,scale:Number,rotation:Number,opacity:Number,color:o,blending:Number}],positionScreen:i})}(e),Jm}function tf(e){const t=Ym.getModelFrom(e);Km=t.discriminator("LensFlare",ef(e))}var rf={getSchemaFrom:ef,getModelFrom:function(e){return Km||tf(e),Km},registerModelTo:function(e){return Km||tf(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:nf}=C;let of=void 0,af=void 0;function sf(e){return of||function(e){const t=e.Schema,r=t.Types.ObjectId;of=new t({geometry:{type:r,ref:"Geometry"},material:[{type:r,ref:"LineBasicMaterial"}],drawMode:Number})}(e),of}function cf(e){const t=nf.getModelFrom(e);af=t.discriminator("Line",sf(e))}var uf={getSchemaFrom:sf,getModelFrom:function(e){return af||cf(e),af},registerModelTo:function(e){return af||cf(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:df}=C;let lf=void 0,mf=void 0;function ff(e){return lf||function(e){const t=e.Schema,r=t.Types.ObjectId;lf=new t({geometry:{type:r,ref:"Geometry"},material:[{type:r,ref:"LineBasicMaterial"}],drawMode:Number})}(e),lf}function hf(e){const t=df.getModelFrom(e);mf=t.discriminator("LineLoop",ff(e))}var gf={getSchemaFrom:ff,getModelFrom:function(e){return mf||hf(e),mf},registerModelTo:function(e){return mf||hf(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:pf}=C;let vf=void 0,yf=void 0;function Sf(e){return vf||function(e){const t=e.Schema,r=t.Types.ObjectId;vf=new t({geometry:{type:r,ref:"Geometry"},material:[{type:r,ref:"LineBasicMaterial"}],drawMode:Number})}(e),vf}function Mf(e){const t=pf.getModelFrom(e);yf=t.discriminator("LineSegments",Sf(e))}var bf={getSchemaFrom:Sf,getModelFrom:function(e){return yf||Mf(e),yf},registerModelTo:function(e){return yf||Mf(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Ff}=C;let _f=void 0,wf=void 0;function Tf(e){return _f||function(e){const t=e.Schema,r=t.Types.Mixed;_f=new t({levels:[r]})}(e),_f}function Nf(e){const t=Ff.getModelFrom(e);wf=t.discriminator("LOD",Tf(e))}var Bf={getSchemaFrom:Tf,getModelFrom:function(e){return wf||Nf(e),wf},registerModelTo:function(e){return wf||Nf(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Of}=C;let Df=void 0,Ef=void 0;function xf(e){return Df||function(e){const t=e.Schema,r=t.Types.ObjectId;Df=new t({geometry:{type:r,ref:"Geometry"},material:[{type:r,ref:"Material"}],drawMode:Number})}(e),Df}function If(e){const t=Of.getModelFrom(e);Ef=t.discriminator("Mesh",xf(e))}var Af={getSchemaFrom:xf,getModelFrom:function(e){return Ef||If(e),Ef},registerModelTo:function(e){return Ef||If(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Cf}=C;let jf=void 0,Lf=void 0;function Pf(e){return jf||function(e){const t=e.Schema,r=t.Types.ObjectId;jf=new t({geometry:{type:r,ref:"Geometry"},material:[{type:r,ref:"PointsMaterial"}],drawMode:Number})}(e),jf}function Gf(e){const t=Cf.getModelFrom(e);Lf=t.discriminator("Points",Pf(e))}var $f={getSchemaFrom:Pf,getModelFrom:function(e){return Lf||Gf(e),Lf},registerModelTo:function(e){return Lf||Gf(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Vf}=C;let Rf=void 0,Uf=void 0;function kf(e){return Rf||function(e){const t=e.Schema,r=t.Types.ObjectId;Rf=new t({bones:[r],boneMatrices:[Number]})}(e),Rf}function zf(e){const t=Vf.getModelFrom(e);Uf=t.discriminator("Skeleton",kf(e))}var Hf={getSchemaFrom:kf,getModelFrom:function(e){return Uf||zf(e),Uf},registerModelTo:function(e){return Uf||zf(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:qf}=C;let Wf=void 0,Qf=void 0;function Zf(e){return Wf||function(e){const t=e.Schema,r=t.Types.ObjectId;Wf=new t({geometry:{type:r,ref:"Geometry"},material:[{type:r,ref:"Material"}],drawMode:Number,bindMode:String,bindMatrix:[Number],bindMatrixInverse:[Number]})}(e),Wf}function Xf(e){const t=qf.getModelFrom(e);Qf=t.discriminator("SkinnedMesh",Zf(e))}var Yf={getSchemaFrom:Zf,getModelFrom:function(e){return Qf||Xf(e),Qf},registerModelTo:function(e){return Qf||Xf(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Object3D:Jf}=C;let Kf=void 0,eh=void 0;function th(e){return Kf||function(e){const t=e.Schema,r=t.Types.ObjectId;Kf=new t({material:[{type:r,ref:"SpriteMaterial"}]})}(e),Kf}function rh(e){const t=Jf.getModelFrom(e);eh=t.discriminator("Sprite",th(e))}var nh={getSchemaFrom:th,getModelFrom:function(e){return eh||rh(e),eh},registerModelTo:function(e){return eh||rh(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */let oh=void 0;var ih={getSchemaFrom:function(e){return oh||function(e){const t=e.Schema;oh=new t({coordinates:{x:Number,y:Number,z:Number},orientation:{x:Number,y:Number,z:Number},thumbnail:Buffer,path:String},{_id:!1,id:!1})}(e),oh},getModelFrom:()=>null,registerModelTo:e=>e},ah={Fog:ih};const{Object3D:sh}=C,{Fog:ch}=ah;let uh=void 0,dh=void 0;function lh(e){return uh||function(e){const t=ch.getSchemaFrom(e),r=e.Schema,n=r.Types.Color;uh=new r({background:n,fog:t,overrideMaterial:String,autoUpdate:Boolean})}(e),uh}function mh(e){const t=sh.getModelFrom(e);dh=t.discriminator("Scene",lh(e))}var fh={getSchemaFrom:lh,getModelFrom:function(e){return dh||mh(e),dh},registerModelTo:function(e){return dh||mh(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module Schemas/Geometry
 *
 * @description Todo...
 */let hh=void 0,gh=void 0;function ph(e){return hh||function(e){const t=e.Schema,r=t.Types,n=r.ObjectId,o=r.Vector2,i=r.Matrix3;hh=new t({uuid:String,name:String,image:n,mipmaps:[],mapping:Number,wrapS:Number,wrapT:Number,magFilter:Number,minFilter:Number,anisotropy:Number,format:Number,type:Number,offset:o,repeat:o,center:o,rotation:Number,matrixAutoUpdate:Boolean,matrix:i,generateMipmaps:Boolean,premultiplyAlpha:Boolean,flipY:Boolean,unpackAlignment:Number,encoding:Number,version:Number},{collection:"textures",discriminatorKey:"type"})}(e),hh}function vh(e){gh=e.model("Textures",ph(e)),gh.discriminator("Texture",new e.Schema({}))}var yh={getSchemaFrom:ph,getModelFrom:function(e){return gh||vh(e),gh},registerModelTo:function(e){return gh||vh(e),e}},Sh={Texture:yh};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
const{Texture:Mh}=Sh;let bh=void 0,Fh=void 0;function _h(e){return bh||function(e){const t=e.Schema;bh=new t({needsUpdate:Boolean})}(e),bh}function wh(e){const t=Mh.getModelFrom(e);Fh=t.discriminator("CanvasTexture",_h(e))}var Th={getSchemaFrom:_h,getModelFrom:function(e){return Fh||wh(e),Fh},registerModelTo:function(e){return Fh||wh(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Texture:Nh}=Sh;let Bh=void 0,Oh=void 0;function Dh(e){return Bh||function(e){const t=e.Schema;Bh=new t({})}(e),Bh}function Eh(e){const t=Nh.getModelFrom(e);Oh=t.discriminator("CompressedTexture",Dh(e))}var xh={getSchemaFrom:Dh,getModelFrom:function(e){return Oh||Eh(e),Oh},registerModelTo:function(e){return Oh||Eh(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Texture:Ih}=Sh;let Ah=void 0,Ch=void 0;function jh(e){return Ah||function(e){const t=e.Schema;Ah=new t({})}(e),Ah}function Lh(e){const t=Ih.getModelFrom(e);Ch=t.discriminator("CubeTexture",jh(e))}var Ph={getSchemaFrom:jh,getModelFrom:function(e){return Ch||Lh(e),Ch},registerModelTo:function(e){return Ch||Lh(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Texture:Gh}=Sh;let $h=void 0,Vh=void 0;function Rh(e){return $h||function(e){const t=e.Schema;$h=new t({})}(e),$h}function Uh(e){const t=Gh.getModelFrom(e);Vh=t.discriminator("DataTexture",Rh(e))}var kh={getSchemaFrom:Rh,getModelFrom:function(e){return Vh||Uh(e),Vh},registerModelTo:function(e){return Vh||Uh(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Texture:zh}=Sh;let Hh=void 0,qh=void 0;function Wh(e){return Hh||function(e){const t=e.Schema;Hh=new t({})}(e),Hh}function Qh(e){const t=zh.getModelFrom(e);qh=t.discriminator("DepthTexture",Wh(e))}var Zh={getSchemaFrom:Wh,getModelFrom:function(e){return qh||Qh(e),qh},registerModelTo:function(e){return qh||Qh(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */const{Texture:Xh}=Sh;let Yh=void 0,Jh=void 0;function Kh(e){return Yh||function(e){const t=e.Schema;Yh=new t({})}(e),Yh}function eg(e){const t=Xh.getModelFrom(e);Jh=t.discriminator("VideoTexture",Kh(e))}var tg={getSchemaFrom:Kh,getModelFrom:function(e){return Jh||eg(e),Jh},registerModelTo:function(e){return Jh||eg(e),e}};
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [MIT]{@link https://opensource.org/licenses/MIT}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
var rg=(new
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
class extends g{constructor(e={}){const t={types:[],schemas:[],...e};super(t),this.types=t.types,this.schemas=t.schemas}get schemas(){return this._schemas}set schemas(e){this._schemas=e}get types(){return this._types}set types(e){this._types=e}addSchema(e){return this._schemas.push(e),this}addType(e){return this._types.push(e),this}beforeRegisterRoutes(e){super.beforeRegisterRoutes(e),this._searchLocalTypes(),this._registerTypes(e),this._searchLocalSchemas(),this._registerSchemas(e)}_searchLocalTypes(){const e=o.join(this.__dirname,"types");if(r.isInvalidDirectoryPath(e))return void console.warn(`Unable to find "types" folder for path "${e}"`);console.log(`Add types from: ${e}`);const t=c.getFilesPathsUnder(e);let n="",i=void 0;for(let e=0,r=t.length;e<r;e++)n=t[e],i=require(n),this._types.push(i)}_registerTypes(e){for(let t of this._types)console.log(`Register type: ${t.name}`),t(e)}_searchLocalSchemas(){const e=o.join(this.__dirname,"schemas");if(r.isInvalidDirectoryPath(e))return void console.warn(`Unable to find "schemas" folder for path "${e}"`);console.log(`Add schemas from: ${e}`);const t=c.getFilesPathsUnder(e);let n="",i=void 0;for(let e=0,o=t.length;e<o;e++)n=t[e],r.isEmptyFile(n)?console.warn(`Skip empty local database schema: ${n}`):(i=require(n),this._schemas.push(i))}_registerSchemas(e){for(let t of this._schemas)console.log(`Register schema: ${t.name}`),r.isFunction(t.registerModelTo)?t.registerModelTo(e):r.isFunction(t)?t(e):console.error(`Unable to register local database schema: ${t}`)}}).addType((function(e){class t extends e.SchemaType{constructor(e,t){super(e,t,"Color")}cast(t){if(r.isNotDefined(t))throw new e.SchemaType.CastError(`Color: ${t} is null or undefined`);if(r.isNotObject(t)&&!t.isColor)throw new e.SchemaType.CastError(`Color: ${t} is not a object or Color instance`);if(!("r"in t))throw new e.SchemaType.CastError(`Color: ${t} does not contain r property`);if(r.isNotNumber(t.r))throw new e.SchemaType.CastError(`Color: ${t} expected to be a number`);if(!("g"in t))throw new e.SchemaType.CastError(`Color: ${t} does not contain g property`);if(r.isNotNumber(t.g))throw new e.SchemaType.CastError(`Color: ${t} expected to be a number`);if(!("b"in t))throw new e.SchemaType.CastError(`Color: ${t} does not contain b property`);if(r.isNotNumber(t.b))throw new e.SchemaType.CastError(`Color: ${t} expected to be a number`);return{r:t.r,g:t.g,b:t.b}}}return t.COLOR_BSON_TYPE=l.BSON_DATA_OBJECT,e.Schema.Types.Color=t,e}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */)).addType((function(e){const t=e.SchemaType,n=e.Schema.Types;function o(e,r){t.call(this,e,r,"Euler")}return o.prototype=Object.assign(Object.create(t.prototype),{cast(e){if(r.isNotDefined(e))throw new Error(`Euler: ${e} is null or undefined`);if(r.isNotObject(e)&&!e.isEuler)throw new Error(`Euler: ${e} is not a object or Euler instance`);if(!("x"in e))throw new Error(`Euler: ${e} does not contain x property`);if(r.isNotNumber(e.x))throw new Error(`Euler: ${e} expected x to be a number`);if(!("y"in e))throw new Error(`Euler: ${e} does not contain y property`);if(r.isNotNumber(e.y))throw new Error(`Euler: ${e} expected y to be a number`);if(!("z"in e))throw new Error(`Euler: ${e} does not contain z property`);if(r.isNotNumber(e.z))throw new Error(`Euler: ${e} expected z to be a number`);if(!("order"in e))throw new Error(`Euler: ${e} does not contain order property`);if(r.isNotString(e.order))throw new Error(`Euler: ${e} expected order to be a string`);if(!["XYZ","YZX","ZXY","XZY","YXZ","ZYX"].includes(e.order.toUpperCase()))throw new Error(`Euler: ${e} expected order to be a string in ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']`);return{x:e.x,y:e.y,z:e.z,order:e.order.toUpperCase()}}}),n.Euler=o,e}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */)).addType((function(e){const t=e.SchemaType,n=e.Schema.Types;function o(e,r){t.call(this,e,r,"Matrix3")}return o.prototype=Object.assign(Object.create(t.prototype),{cast(e){if(r.isNotDefined(e))throw new Error(`Matrix3: ${e} is null or undefined`);if(r.isNotArray(e)&&!e.isMatrix3)throw new Error(`Matrix3: ${e} is not a object or Matrix3 instance`);let t=void 0;t=e.isMatrix3?e.toArray():e;const n=t.length;if(9!==n)throw new Error(`Matrix3: ${e} does not contain the right number of values. Expect 9 values and found ${n}`);for(let o=0,i=void 0;o<n;o++){if(i=t[o],r.isNotNumber(i))throw new Error(`Matrix3: ${e} does not seem to contain right values. Expect values in range 0 and 1.`);if(r.isNaN(i))throw new Error(`Matrix3: ${e} does not seem to contain right values. Expect values in range 0 and 1.`)}return t}}),n.Matrix3=o,e}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */)).addType((function(e){const t=e.SchemaType,n=e.Schema.Types;function o(e,r){t.call(this,e,r,"Matrix4")}return o.prototype=Object.assign(Object.create(t.prototype),{cast(e){if(r.isNotDefined(e))throw new Error(`Matrix4: ${e} is null or undefined`);if(r.isNotArray(e)&&!e.isMatrix4)throw new Error(`Matrix4: ${e} is not a object or Matrix4 instance`);let t=void 0;t=e.isMatrix4?e.toArray():e;const n=t.length;if(16!==n)throw new Error(`Matrix4: ${e} does not contain the right number of values. Expect 9 values and found ${n}`);for(let o=0,i=void 0;o<n;o++){if(i=t[o],r.isNotNumber(i))throw new Error(`Matrix4: ${e} does not seem to contain right values. Expect values in range 0 and 1.`);if(r.isNaN(i))throw new Error(`Matrix4: ${e} does not seem to contain right values. Expect values in range 0 and 1.`)}return t}}),n.Matrix4=o,e}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */)).addType((function(e){const t=e.SchemaType,n=e.Schema.Types;function o(e,r){t.call(this,e,r,"Quaternion")}return o.prototype=Object.assign(Object.create(t.prototype),{cast(e){if(r.isNotDefined(e))throw new Error(`Quaternion: ${e} is null or undefined`);if(!("x"in e))throw new Error(`Quaternion: ${e} does not contain x property`);if(r.isNotNumber(e.x))throw new Error(`Quaternion: ${e} expected to be a number`);if(!("y"in e))throw new Error(`Quaternion: ${e} does not contain y property`);if(r.isNotNumber(e.y))throw new Error(`Quaternion: ${e} expected to be a number`);if(!("z"in e))throw new Error(`Quaternion: ${e} does not contain z property`);if(r.isNotNumber(e.z))throw new Error(`Quaternion: ${e} expected to be a number`);if(!("w"in e))throw new Error(`Quaternion: ${e} does not contain w property`);if(r.isNotNumber(e.w))throw new Error(`Quaternion: ${e} expected to be a number`);return{x:e.x,y:e.y,z:e.z,w:e.w}}}),n.Quaternion=o,e}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */)).addType((function(e){const t=e.SchemaType,n=e.Schema.Types;function o(e,r){t.call(this,e,r,"Vector2")}return o.prototype=Object.assign(Object.create(t.prototype),{cast(e){if(r.isNotDefined(e))throw new Error(`Vector2: ${e} is null or undefined`);if(r.isNotObject(e)&&!e.isVector2)throw new Error(`Vector2: ${e} is not a object or Vector2 instance`);if(!("x"in e))throw new Error(`Vector2: ${e} does not contain x property`);if(r.isNotNumber(e.x))throw new Error(`Vector2: ${e} expected to be a number`);if(!("y"in e))throw new Error(`Vector2: ${e} does not contain y property`);if(r.isNotNumber(e.y))throw new Error(`Vector2: ${e} expected to be a number`);return{x:e.x,y:e.y}}}),n.Vector2=o,e}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */)).addType((function(e){const t=e.SchemaType,n=e.Schema.Types;function o(e,r){t.call(this,e,r,"Vector3")}return o.prototype=Object.assign(Object.create(t.prototype),{cast(e){if(r.isNotDefined(e))throw new Error(`Vector3: ${e} is null or undefined`);if(r.isNotObject(e)&&!e.isVector3)throw new Error(`Vector3: ${e} is not a object or Vector3 instance`);if(!("x"in e))throw new Error(`Vector3: ${e} does not contain x property`);if(r.isNotNumber(e.x))throw new Error(`Vector3: ${e} expected to be a number`);if(!("y"in e))throw new Error(`Vector3: ${e} does not contain y property`);if(r.isNotNumber(e.y))throw new Error(`Vector3: ${e} expected to be a number`);if(!("z"in e))throw new Error(`Vector3: ${e} does not contain z property`);if(r.isNotNumber(e.z))throw new Error(`Vector3: ${e} expected to be a number`);return{x:e.x,y:e.y,z:e.z}}}),n.Vector3=o,e}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */)).addType((function(e){const t=e.SchemaType,n=e.Schema.Types;function o(e,r){t.call(this,e,r,"Vector4")}return o.prototype=Object.assign(Object.create(t.prototype),{cast(e){if(r.isNotDefined(e))throw new Error(`Vector4: ${e} is null or undefined`);if(r.isNotObject(e)&&!e.isVector4)throw new Error(`Vector4: ${e} is not a object or Vector4 instance`);if(!("x"in e))throw new Error(`Vector4: ${e} does not contain x property`);if(r.isNotNumber(e.x))throw new Error(`Vector4: ${e} expected to be a number`);if(!("y"in e))throw new Error(`Vector4: ${e} does not contain y property`);if(r.isNotNumber(e.y))throw new Error(`Vector4: ${e} expected to be a number`);if(!("z"in e))throw new Error(`Vector4: ${e} does not contain z property`);if(r.isNotNumber(e.z))throw new Error(`Vector4: ${e} expected to be a number`);if(!("w"in e))throw new Error(`Vector4: ${e} does not contain w property`);if(r.isNotNumber(e.w))throw new Error(`Vector4: ${e} expected to be a number`);return{x:e.x,y:e.y,z:e.z,w:e.w}}}),n.Vector4=o,e})).addSchema(V).addSchema(q).addSchema(J).addSchema(oe).addSchema(de).addSchema(pe).addSchema(Fe).addSchema(Oe).addSchema(Re).addSchema(Qe).addSchema(st).addSchema(ut).addSchema(ht).addSchema(A).addSchema(bt).addSchema(Bt).addSchema(At).addSchema($t).addSchema(Ht).addSchema(Yt).addSchema(et).addSchema(nr).addSchema(ur).addSchema(gr).addSchema(br).addSchema(Br).addSchema(Ar).addSchema($r).addSchema(Hr).addSchema(Yr).addSchema(nn).addSchema(dn).addSchema(pn).addSchema(Fn).addSchema(On).addSchema(Cn).addSchema(Vn).addSchema(qn).addSchema(Jn).addSchema(oo).addSchema(lo).addSchema(vo).addSchema(_o).addSchema(Do).addSchema(jo).addSchema(Ro).addSchema(Wo).addSchema(Ko).addSchema(ii).addSchema(li).addSchema(vi).addSchema(_i).addSchema(Di).addSchema(ji).addSchema(Ri).addSchema(Wi).addSchema(Ki).addSchema(ia).addSchema(la).addSchema(va).addSchema(_a).addSchema(Da).addSchema(ja).addSchema(Ra).addSchema(Wa).addSchema(Ka).addSchema(is).addSchema(ls).addSchema(vs).addSchema(_s).addSchema(Ds).addSchema(js).addSchema(Rs).addSchema(Ws).addSchema(Ks).addSchema(ic).addSchema(lc).addSchema(vc).addSchema(_c).addSchema(Dc).addSchema(jc).addSchema(Rc).addSchema(Wc).addSchema(Kc).addSchema(iu).addSchema(lu).addSchema(vu).addSchema(_u).addSchema(Du).addSchema(ju).addSchema(Ru).addSchema(Wu).addSchema(Ku).addSchema(id).addSchema(ld).addSchema(vd).addSchema(_d).addSchema(Dd).addSchema(_l).addSchema(Rd).addSchema(Wd).addSchema(Cd).addSchema(Kd).addSchema(il).addSchema(ll).addSchema(vl).addSchema(Dl).addSchema(jl).addSchema(Rl).addSchema(Wl).addSchema(Kl).addSchema(im).addSchema(lm).addSchema(vm).addSchema(Sm).addSchema(bm).addSchema(_m).addSchema(Tm).addSchema(Bm).addSchema(Dm).addSchema(xm).addSchema(Am).addSchema($m).addSchema(zm).addSchema(Xm).addSchema(rf).addSchema(uf).addSchema(gf).addSchema(bf).addSchema(Bf).addSchema(Af).addSchema($f).addSchema(Hf).addSchema(Yf).addSchema(nh).addSchema(ih).addSchema(fh).addSchema(Th).addSchema(xh).addSchema(Ph).addSchema(kh).addSchema(Zh).addSchema(yh).addSchema(tg).addController(class extends m{constructor(e={}){const t={driver:null,schemaName:"",...e};super(t),this.databaseSchema=this._driver.model(t.schemaName)}get databaseSchema(){return this._databaseSchema}set databaseSchema(e){if(r.isNull(e))throw new TypeError("Database schema cannot be null.");if(r.isUndefined(e))throw new TypeError("Database schema cannot be undefined.");this._databaseSchema=e}setDatabaseSchema(e){return this.databaseSchema=e,this}_createMany(e,t){super._createMany(e,t),this._databaseSchema.create(e,this.return(t))}_createOne(e,t){super._createOne(e,t),this._databaseSchema.create(e,this.return(t))}_deleteAll(e){super._deleteAll(e),this._databaseSchema.collection.drop(this.return(e))}_deleteMany(e,t){super._deleteMany(e,t),this._databaseSchema.deleteMany({_id:{$in:e}},this.return(t))}_deleteOne(e,t){super._deleteOne(e,t),this._databaseSchema.findByIdAndDelete(e).then(e=>m.returnData(e,t)).catch(e=>m.returnError(e,t))}_deleteWhere(e,t){super._deleteWhere(e,t),this._databaseSchema.deleteMany(e,this.return(t))}_readAll(e,t){super._readAll(e,t),this._databaseSchema.find({},e).lean().exec().then(e=>m.returnData(e,t)).catch(e=>m.returnError(e,t))}_readMany(e,t,n){super._readMany(e,t,n),this._databaseSchema.find({_id:{$in:e}},t).lean().exec().then(t=>{r.isNull(t)||r.isEmptyArray(t)?m.returnNotFound(n):e.length!==t.length?m.returnErrorAndData({title:"Missing data",message:"Some requested objects could not be found."},t,n):m.returnData(t,n)}).catch(e=>m.returnError(e,n))}_readOne(e,t,n){super._readOne(e,t,n),this._databaseSchema.findById(e,t).lean().exec().then(e=>{r.isNull(e)?m.returnNotFound(n):m.returnData(e,n)}).catch(e=>m.returnError(e,n))}_readWhere(e,t,r){super._readWhere(e,t,r),this._databaseSchema.find(e,t).lean().exec().then(e=>m.returnData(e,r)).catch(e=>m.returnError(e,r))}_updateAll(e,t){super._updateAll(e,t),this._databaseSchema.update({},e,{multi:!0},this.return(t))}_updateMany(e,t,r){super._updateMany(e,t,r),this._databaseSchema.update({_id:{$in:e}},t,{multi:!0},this.return(r))}_updateOne(e,t,r){super._updateOne(e,t,r),this._databaseSchema.findByIdAndUpdate(e,t).exec().then(e=>m.returnData(e,r)).catch(e=>m.returnError(e,r))}_updateWhere(e,t,r){super._updateWhere(e,t,r),this._databaseSchema.update(e,t,{multi:!0},this.return(r))}}).addDescriptor({route:"/objects",controller:{name:"TMongooseController",options:{schemaName:"Objects3D"},can:{create:{on:"put",over:"/(:id)?"},read:{on:"post",over:"/(:id)?"},update:{on:"patch",over:"/(:id)?"},delete:{on:"delete",over:"/(:id)?"}}}}).addDescriptor({route:"/curves",controller:{name:"TMongooseController",options:{schemaName:"Curves"},can:{create:{on:"put",over:"/(:id)?"},read:{on:"post",over:"/(:id)?"},update:{on:"patch",over:"/(:id)?"},delete:{on:"delete",over:"/(:id)?"}}}}).addDescriptor({route:"/geometries",controller:{name:"TMongooseController",options:{schemaName:"Geometries"},can:{create:{on:"put",over:"/(:id)?"},read:{on:"post",over:"/(:id)?"},update:{on:"patch",over:"/(:id)?"},delete:{on:"delete",over:"/(:id)?"}}}}).addDescriptor({route:"/materials",controller:{name:"TMongooseController",options:{schemaName:"Materials"},can:{create:{on:"put",over:"/(:id)?"},read:{on:"post",over:"/(:id)?"},update:{on:"patch",over:"/(:id)?"},delete:{on:"delete",over:"/(:id)?"}}}}).addDescriptor({route:"/textures",controller:{name:"TMongooseController",options:{schemaName:"Textures"},can:{create:{on:"put",over:"/(:id)?"},read:{on:"post",over:"/(:id)?"},update:{on:"patch",over:"/(:id)?"},delete:{on:"delete",over:"/(:id)?"}}}}).addController(t.TAbstractConverterManager).addDescriptor({route:"/uploads",controller:{name:"TAbstractConverterManager",options:{useNext:!0,converters:{JsonToThree:new F,ShpToThree:new D,DbfToThree:new M,FbxToThree:new b,ColladaToThree:new p,StlToThree:new E,TdsToThree:new x,MtlToThree:new _,ObjToThree:new w},rules:[{on:".json",use:"JsonToThree"},{on:".dae",use:"ColladaToThree"},{on:".fbx",use:"FbxToThree"},{on:".stl",use:"StlToThree"},{on:".3ds",use:"TdsToThree"},{on:".shp",use:"ShpToThree"},{on:".dbf",use:"DbfToThree"},{on:[".shp",".dbf"],use:["ShpToThree","DbfToThree"]},{on:".mtl",use:"MtlToThree"},{on:".obj",use:"ObjToThree"},{on:[".mtl",".obj"],use:["MtlToThree","ObjToThree"]}],inserter:I},can:{processFiles:{on:"post",over:"/"}}}});module.exports=rg;
//# sourceMappingURL=itee-plugin-three.cjs.min.js.map
